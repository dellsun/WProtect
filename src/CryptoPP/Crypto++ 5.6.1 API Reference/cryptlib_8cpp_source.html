<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Crypto++: cryptlib.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>cryptlib.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// cryptlib.cpp - written and placed in the public domain by Wei Dai</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include &quot;pch.h&quot;</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="preprocessor">#ifndef CRYPTOPP_IMPORTS</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &quot;<a class="code" href="cryptlib_8h.html">cryptlib.h</a>&quot;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;misc.h&quot;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;<a class="code" href="filters_8h.html">filters.h</a>&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;algparam.h&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;<a class="code" href="fips140_8h.html">fips140.h</a>&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;argnames.h&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;fltrimpl.h&quot;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;trdlocal.h&quot;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &quot;<a class="code" href="osrng_8h.html">osrng.h</a>&quot;</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 NAMESPACE_BEGIN(CryptoPP)
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 CRYPTOPP_COMPILE_ASSERT(sizeof(byte) == 1);
<a name="l00022"></a>00022 CRYPTOPP_COMPILE_ASSERT(sizeof(word16) == 2);
<a name="l00023"></a>00023 CRYPTOPP_COMPILE_ASSERT(sizeof(word32) == 4);
<a name="l00024"></a>00024 CRYPTOPP_COMPILE_ASSERT(sizeof(word64) == 8);
<a name="l00025"></a>00025 <span class="preprocessor">#ifdef CRYPTOPP_NATIVE_DWORD_AVAILABLE</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>CRYPTOPP_COMPILE_ASSERT(<span class="keyword">sizeof</span>(dword) == 2*<span class="keyword">sizeof</span>(word));
<a name="l00027"></a>00027 <span class="preprocessor">#endif</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00029"></a><a class="code" href="cryptlib_8h.html#a9a69ab5a5e0f58279c43f4f51809c84a">00029</a> <span class="keyword">const</span> std::string DEFAULT_CHANNEL;
<a name="l00030"></a><a class="code" href="cryptlib_8h.html#aff60e2d96212d25c078c2dd11e45de0e">00030</a> <span class="keyword">const</span> std::string AAD_CHANNEL = <span class="stringliteral">&quot;AAD&quot;</span>;
<a name="l00031"></a>00031 <span class="keyword">const</span> std::string &amp;BufferedTransformation::NULL_CHANNEL = DEFAULT_CHANNEL;
<a name="l00032"></a>00032 
<a name="l00033"></a><a class="code" href="class_null_name_value_pairs.html">00033</a> <span class="keyword">class </span><a class="code" href="class_null_name_value_pairs.html">NullNameValuePairs</a> : <span class="keyword">public</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a>
<a name="l00034"></a>00034 {
<a name="l00035"></a>00035 <span class="keyword">public</span>:
<a name="l00036"></a><a class="code" href="class_null_name_value_pairs.html#acf9413816ce2ada3ec085c2e30dfac2d">00036</a>         <span class="keywordtype">bool</span> <a class="code" href="class_null_name_value_pairs.html#acf9413816ce2ada3ec085c2e30dfac2d" title="to be implemented by derived classes, users should use one of the above functions instead...">GetVoidValue</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> std::type_info &amp;valueType, <span class="keywordtype">void</span> *pValue)<span class="keyword"> const </span>{<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00037"></a>00037 };
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <a class="code" href="classsimple__ptr.html">simple_ptr&lt;NullNameValuePairs&gt;</a> s_pNullNameValuePairs(<span class="keyword">new</span> <a class="code" href="class_null_name_value_pairs.html">NullNameValuePairs</a>);
<a name="l00040"></a><a class="code" href="cryptlib_8h.html#aa9048ef24353685fd0dcc4180c6884c2">00040</a> <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;g_nullNameValuePairs = *s_pNullNameValuePairs.m_p;
<a name="l00041"></a>00041 
<a name="l00042"></a><a class="code" href="cryptlib_8h.html#ae42d0f5e86285a0fd540be52caabbfeb">00042</a> <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp; TheBitBucket()
<a name="l00043"></a>00043 {
<a name="l00044"></a>00044         <span class="keyword">static</span> <a class="code" href="class_bit_bucket.html">BitBucket</a> bitBucket;
<a name="l00045"></a>00045         <span class="keywordflow">return</span> bitBucket;
<a name="l00046"></a>00046 }
<a name="l00047"></a>00047 
<a name="l00048"></a><a class="code" href="class_algorithm.html#a1c77f5117ca2cd881baf26a364cfc606">00048</a> <a class="code" href="class_algorithm.html#a1c77f5117ca2cd881baf26a364cfc606">Algorithm::Algorithm</a>(<span class="keywordtype">bool</span> checkSelfTestStatus)
<a name="l00049"></a>00049 {
<a name="l00050"></a>00050         <span class="keywordflow">if</span> (checkSelfTestStatus &amp;&amp; FIPS_140_2_ComplianceEnabled())
<a name="l00051"></a>00051         {
<a name="l00052"></a>00052                 <span class="keywordflow">if</span> (GetPowerUpSelfTestStatus() == POWER_UP_SELF_TEST_NOT_DONE &amp;&amp; !PowerUpSelfTestInProgressOnThisThread())
<a name="l00053"></a>00053                         <span class="keywordflow">throw</span> <a class="code" href="class_self_test_failure.html" title="exception thrown when a crypto algorithm is used after a self test fails">SelfTestFailure</a>(<span class="stringliteral">&quot;Cryptographic algorithms are disabled before the power-up self tests are performed.&quot;</span>);
<a name="l00054"></a>00054 
<a name="l00055"></a>00055                 <span class="keywordflow">if</span> (GetPowerUpSelfTestStatus() == POWER_UP_SELF_TEST_FAILED)
<a name="l00056"></a>00056                         <span class="keywordflow">throw</span> <a class="code" href="class_self_test_failure.html" title="exception thrown when a crypto algorithm is used after a self test fails">SelfTestFailure</a>(<span class="stringliteral">&quot;Cryptographic algorithms are disabled after a power-up self test failed.&quot;</span>);
<a name="l00057"></a>00057         }
<a name="l00058"></a>00058 }
<a name="l00059"></a>00059 
<a name="l00060"></a><a class="code" href="class_simple_keying_interface.html#adf3c29b3ef3af74788a58c7c49887fd7">00060</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_keying_interface.html#adf3c29b3ef3af74788a58c7c49887fd7" title="set or reset the key of this object">SimpleKeyingInterface::SetKey</a>(<span class="keyword">const</span> byte *key, <span class="keywordtype">size_t</span> length, <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;params)
<a name="l00061"></a>00061 {
<a name="l00062"></a>00062         this-&gt;ThrowIfInvalidKeyLength(length);
<a name="l00063"></a>00063         this-&gt;UncheckedSetKey(key, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)length, params);
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 
<a name="l00066"></a><a class="code" href="class_simple_keying_interface.html#a0401f9c67930805180964bc02ae0ac1c">00066</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_keying_interface.html#a0401f9c67930805180964bc02ae0ac1c" title="calls SetKey() with an NameValuePairs object that just specifies &amp;quot;Rounds&amp;quot;">SimpleKeyingInterface::SetKeyWithRounds</a>(<span class="keyword">const</span> byte *key, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> rounds)
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068         <a class="code" href="class_simple_keying_interface.html#adf3c29b3ef3af74788a58c7c49887fd7" title="set or reset the key of this object">SetKey</a>(key, length, MakeParameters(<a class="code" href="namespace_name.html#aef07deb188a711a240d95f3ccddc9e8e" title="int">Name::Rounds</a>(), rounds));
<a name="l00069"></a>00069 }
<a name="l00070"></a>00070 
<a name="l00071"></a><a class="code" href="class_simple_keying_interface.html#a5b4e358c514fd743840967bc595a34c2">00071</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_keying_interface.html#a5b4e358c514fd743840967bc595a34c2" title="calls SetKey() with an NameValuePairs object that just specifies &amp;quot;IV&amp;quot;">SimpleKeyingInterface::SetKeyWithIV</a>(<span class="keyword">const</span> byte *key, <span class="keywordtype">size_t</span> length, <span class="keyword">const</span> byte *iv, <span class="keywordtype">size_t</span> ivLength)
<a name="l00072"></a>00072 {
<a name="l00073"></a>00073         <a class="code" href="class_simple_keying_interface.html#adf3c29b3ef3af74788a58c7c49887fd7" title="set or reset the key of this object">SetKey</a>(key, length, MakeParameters(<a class="code" href="namespace_name.html#a9b6839240a8bdf1f5bcbebf1866f4733" title="ConstByteArrayParameter, also accepts const byte * for backwards compatibility.">Name::IV</a>(), <a class="code" href="class_const_byte_array_parameter.html" title="used to pass byte array input as part of a NameValuePairs object">ConstByteArrayParameter</a>(iv, ivLength)));
<a name="l00074"></a>00074 }
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="keywordtype">void</span> SimpleKeyingInterface::ThrowIfInvalidKeyLength(<span class="keywordtype">size_t</span> length)
<a name="l00077"></a>00077 {
<a name="l00078"></a>00078         <span class="keywordflow">if</span> (!<a class="code" href="class_simple_keying_interface.html#a024f23c0a094ee46094f69ffefb91d17" title="returns whether n is a valid key length">IsValidKeyLength</a>(length))
<a name="l00079"></a>00079                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_key_length.html" title="_">InvalidKeyLength</a>(GetAlgorithm().AlgorithmName(), length);
<a name="l00080"></a>00080 }
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="keywordtype">void</span> SimpleKeyingInterface::ThrowIfResynchronizable()
<a name="l00083"></a>00083 {
<a name="l00084"></a>00084         <span class="keywordflow">if</span> (<a class="code" href="class_simple_keying_interface.html#ad263f4a96fa8b4e7d01fea8ccaae9d3b" title="returns whether this object can be resynchronized (i.e. supports initialization vectors)">IsResynchronizable</a>())
<a name="l00085"></a>00085                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(GetAlgorithm().AlgorithmName() + <span class="stringliteral">&quot;: this object requires an IV&quot;</span>);
<a name="l00086"></a>00086 }
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="keywordtype">void</span> SimpleKeyingInterface::ThrowIfInvalidIV(<span class="keyword">const</span> byte *iv)
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090         <span class="keywordflow">if</span> (!iv &amp;&amp; <a class="code" href="class_simple_keying_interface.html#a867b535e5c4a11704d0645272e8b03f9" title="returns the minimal requirement for secure IVs">IVRequirement</a>() == UNPREDICTABLE_RANDOM_IV)
<a name="l00091"></a>00091                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(GetAlgorithm().AlgorithmName() + <span class="stringliteral">&quot;: this object cannot use a null IV&quot;</span>);
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="keywordtype">size_t</span> SimpleKeyingInterface::ThrowIfInvalidIVLength(<span class="keywordtype">int</span> size)
<a name="l00095"></a>00095 {
<a name="l00096"></a>00096         <span class="keywordflow">if</span> (size &lt; 0)
<a name="l00097"></a>00097                 <span class="keywordflow">return</span> IVSize();
<a name="l00098"></a>00098         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<span class="keywordtype">size_t</span>)size &lt; <a class="code" href="class_simple_keying_interface.html#a4450efa449a2e04a31b6371821e650f9" title="returns minimal length of IVs accepted by this object">MinIVLength</a>())
<a name="l00099"></a>00099                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(GetAlgorithm().AlgorithmName() + <span class="stringliteral">&quot;: IV length &quot;</span> + IntToString(size) + <span class="stringliteral">&quot; is less than the minimum of &quot;</span> + IntToString(<a class="code" href="class_simple_keying_interface.html#a4450efa449a2e04a31b6371821e650f9" title="returns minimal length of IVs accepted by this object">MinIVLength</a>()));
<a name="l00100"></a>00100         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<span class="keywordtype">size_t</span>)size &gt; <a class="code" href="class_simple_keying_interface.html#a308799c135440e57a583defe3860f02e" title="returns maximal length of IVs accepted by this object">MaxIVLength</a>())
<a name="l00101"></a>00101                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(GetAlgorithm().AlgorithmName() + <span class="stringliteral">&quot;: IV length &quot;</span> + IntToString(size) + <span class="stringliteral">&quot; exceeds the maximum of &quot;</span> + IntToString(<a class="code" href="class_simple_keying_interface.html#a308799c135440e57a583defe3860f02e" title="returns maximal length of IVs accepted by this object">MaxIVLength</a>()));
<a name="l00102"></a>00102         <span class="keywordflow">else</span>
<a name="l00103"></a>00103                 <span class="keywordflow">return</span> size;
<a name="l00104"></a>00104 }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="keyword">const</span> byte * SimpleKeyingInterface::GetIVAndThrowIfInvalid(<span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;params, <span class="keywordtype">size_t</span> &amp;size)
<a name="l00107"></a>00107 {
<a name="l00108"></a>00108         <a class="code" href="class_const_byte_array_parameter.html" title="used to pass byte array input as part of a NameValuePairs object">ConstByteArrayParameter</a> ivWithLength;
<a name="l00109"></a>00109         <span class="keyword">const</span> byte *iv;
<a name="l00110"></a>00110         <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112         <span class="keywordflow">try</span> {found = params.<a class="code" href="class_name_value_pairs.html#a96686e9f8d6ce3ab870e516fb72b608e" title="get a named value, returns true if the name exists">GetValue</a>(<a class="code" href="namespace_name.html#a9b6839240a8bdf1f5bcbebf1866f4733" title="ConstByteArrayParameter, also accepts const byte * for backwards compatibility.">Name::IV</a>(), ivWithLength);}
<a name="l00113"></a>00113         <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="class_name_value_pairs_1_1_value_type_mismatch.html" title="exception thrown when trying to retrieve a value using a different type than expected">NameValuePairs::ValueTypeMismatch</a> &amp;) {}
<a name="l00114"></a>00114 
<a name="l00115"></a>00115         <span class="keywordflow">if</span> (found)
<a name="l00116"></a>00116         {
<a name="l00117"></a>00117                 iv = ivWithLength.begin();
<a name="l00118"></a>00118                 ThrowIfInvalidIV(iv);
<a name="l00119"></a>00119                 size = ThrowIfInvalidIVLength((<span class="keywordtype">int</span>)ivWithLength.size());
<a name="l00120"></a>00120                 <span class="keywordflow">return</span> iv;
<a name="l00121"></a>00121         }
<a name="l00122"></a>00122         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (params.<a class="code" href="class_name_value_pairs.html#a96686e9f8d6ce3ab870e516fb72b608e" title="get a named value, returns true if the name exists">GetValue</a>(<a class="code" href="namespace_name.html#a9b6839240a8bdf1f5bcbebf1866f4733" title="ConstByteArrayParameter, also accepts const byte * for backwards compatibility.">Name::IV</a>(), iv))
<a name="l00123"></a>00123         {
<a name="l00124"></a>00124                 ThrowIfInvalidIV(iv);
<a name="l00125"></a>00125                 size = IVSize();
<a name="l00126"></a>00126                 <span class="keywordflow">return</span> iv;
<a name="l00127"></a>00127         }
<a name="l00128"></a>00128         <span class="keywordflow">else</span>
<a name="l00129"></a>00129         {
<a name="l00130"></a>00130                 ThrowIfResynchronizable();
<a name="l00131"></a>00131                 size = 0;
<a name="l00132"></a>00132                 <span class="keywordflow">return</span> NULL;
<a name="l00133"></a>00133         }
<a name="l00134"></a>00134 }
<a name="l00135"></a>00135 
<a name="l00136"></a><a class="code" href="class_simple_keying_interface.html#a917224bb6df7431d6469e7a10feac5fa">00136</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_keying_interface.html#a917224bb6df7431d6469e7a10feac5fa" title="get a secure IV for the next message">SimpleKeyingInterface::GetNextIV</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, byte *IV)
<a name="l00137"></a>00137 {
<a name="l00138"></a>00138         rng.<a class="code" href="class_random_number_generator.html#a497145546d24e6d4abaf10b7e0f1ba17" title="generate random array of bytes">GenerateBlock</a>(IV, IVSize());
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00141"></a><a class="code" href="class_block_transformation.html#adcff119bb709c84bfaaab8d1871b018c">00141</a> <span class="keywordtype">size_t</span> <a class="code" href="class_block_transformation.html#adcff119bb709c84bfaaab8d1871b018c" title="encrypt and xor blocks according to flags (see FlagsForAdvancedProcessBlocks)">BlockTransformation::AdvancedProcessBlocks</a>(<span class="keyword">const</span> byte *inBlocks, <span class="keyword">const</span> byte *xorBlocks, byte *outBlocks, <span class="keywordtype">size_t</span> length, word32 flags)<span class="keyword"> const</span>
<a name="l00142"></a>00142 <span class="keyword"></span>{
<a name="l00143"></a>00143         <span class="keywordtype">size_t</span> blockSize = <a class="code" href="class_block_transformation.html#adfdb78b033996020435c3dcffdca76ce" title="block size of the cipher in bytes">BlockSize</a>();
<a name="l00144"></a>00144         <span class="keywordtype">size_t</span> inIncrement = (flags &amp; (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;
<a name="l00145"></a>00145         <span class="keywordtype">size_t</span> xorIncrement = xorBlocks ? blockSize : 0;
<a name="l00146"></a>00146         <span class="keywordtype">size_t</span> outIncrement = (flags &amp; BT_DontIncrementInOutPointers) ? 0 : blockSize;
<a name="l00147"></a>00147 
<a name="l00148"></a>00148         <span class="keywordflow">if</span> (flags &amp; BT_ReverseDirection)
<a name="l00149"></a>00149         {
<a name="l00150"></a>00150                 assert(length % blockSize == 0);
<a name="l00151"></a>00151                 inBlocks += length - blockSize;
<a name="l00152"></a>00152                 xorBlocks += length - blockSize;
<a name="l00153"></a>00153                 outBlocks += length - blockSize;
<a name="l00154"></a>00154                 inIncrement = 0-inIncrement;
<a name="l00155"></a>00155                 xorIncrement = 0-xorIncrement;
<a name="l00156"></a>00156                 outIncrement = 0-outIncrement;
<a name="l00157"></a>00157         }
<a name="l00158"></a>00158 
<a name="l00159"></a>00159         <span class="keywordflow">while</span> (length &gt;= blockSize)
<a name="l00160"></a>00160         {
<a name="l00161"></a>00161                 <span class="keywordflow">if</span> (flags &amp; BT_XorInput)
<a name="l00162"></a>00162                 {
<a name="l00163"></a>00163                         xorbuf(outBlocks, xorBlocks, inBlocks, blockSize);
<a name="l00164"></a>00164                         <a class="code" href="class_block_transformation.html#a2fefb3f4c6c6297c0c91fcbba9e4f4f3" title="encrypt or decrypt one block">ProcessBlock</a>(outBlocks);
<a name="l00165"></a>00165                 }
<a name="l00166"></a>00166                 <span class="keywordflow">else</span>
<a name="l00167"></a>00167                         <a class="code" href="class_block_transformation.html#a1904cf145e4c5c650dd7aff32f54e153" title="encrypt or decrypt inBlock, xor with xorBlock, and write to outBlock">ProcessAndXorBlock</a>(inBlocks, xorBlocks, outBlocks);
<a name="l00168"></a>00168                 <span class="keywordflow">if</span> (flags &amp; BT_InBlockIsCounter)
<a name="l00169"></a>00169                         <span class="keyword">const_cast&lt;</span>byte *<span class="keyword">&gt;</span>(inBlocks)[blockSize-1]++;
<a name="l00170"></a>00170                 inBlocks += inIncrement;
<a name="l00171"></a>00171                 outBlocks += outIncrement;
<a name="l00172"></a>00172                 xorBlocks += xorIncrement;
<a name="l00173"></a>00173                 length -= blockSize;
<a name="l00174"></a>00174         }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176         <span class="keywordflow">return</span> length;
<a name="l00177"></a>00177 }
<a name="l00178"></a>00178 
<a name="l00179"></a><a class="code" href="class_block_transformation.html#a0f53d1bce5bc7d7de661b84a4c954244">00179</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_block_transformation.html#a0f53d1bce5bc7d7de661b84a4c954244" title="returns how inputs and outputs should be aligned for optimal performance">BlockTransformation::OptimalDataAlignment</a>()<span class="keyword"> const</span>
<a name="l00180"></a>00180 <span class="keyword"></span>{
<a name="l00181"></a>00181         <span class="keywordflow">return</span> GetAlignmentOf&lt;word32&gt;();
<a name="l00182"></a>00182 }
<a name="l00183"></a>00183 
<a name="l00184"></a><a class="code" href="class_stream_transformation.html#af6ed3c4f1c8582f62096263e76ed98f5">00184</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_stream_transformation.html#af6ed3c4f1c8582f62096263e76ed98f5" title="returns how input should be aligned for optimal performance">StreamTransformation::OptimalDataAlignment</a>()<span class="keyword"> const</span>
<a name="l00185"></a>00185 <span class="keyword"></span>{
<a name="l00186"></a>00186         <span class="keywordflow">return</span> GetAlignmentOf&lt;word32&gt;();
<a name="l00187"></a>00187 }
<a name="l00188"></a>00188 
<a name="l00189"></a><a class="code" href="class_hash_transformation.html#ad44c14bc654ba3be366da88e0a27f169">00189</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_hash_transformation.html#ad44c14bc654ba3be366da88e0a27f169" title="returns how input should be aligned for optimal performance">HashTransformation::OptimalDataAlignment</a>()<span class="keyword"> const</span>
<a name="l00190"></a>00190 <span class="keyword"></span>{
<a name="l00191"></a>00191         <span class="keywordflow">return</span> GetAlignmentOf&lt;word32&gt;();
<a name="l00192"></a>00192 }
<a name="l00193"></a>00193 
<a name="l00194"></a><a class="code" href="class_stream_transformation.html#a0668b78edaea082f87bf3e878c4c02f7">00194</a> <span class="keywordtype">void</span> <a class="code" href="class_stream_transformation.html#a0668b78edaea082f87bf3e878c4c02f7" title="for ciphers where the last block of data is special, encrypt or decrypt the last block of data...">StreamTransformation::ProcessLastBlock</a>(byte *outString, <span class="keyword">const</span> byte *inString, <span class="keywordtype">size_t</span> length)
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196         assert(<a class="code" href="class_stream_transformation.html#a2eb96f3a8fae23cb9f85acb288e3bcbe" title="returns the minimum size of the last block, 0 indicating the last block is not special">MinLastBlockSize</a>() == 0);        <span class="comment">// this function should be overriden otherwise</span>
<a name="l00197"></a>00197 
<a name="l00198"></a>00198         <span class="keywordflow">if</span> (length == <a class="code" href="class_stream_transformation.html#a3638ff7580edb42a5b1c367e53a7436f" title="returns block size, if input must be processed in blocks, otherwise 1">MandatoryBlockSize</a>())
<a name="l00199"></a>00199                 <a class="code" href="class_stream_transformation.html#a26feabde21bc4d1783195969733e3bb0" title="encrypt or decrypt an array of bytes of specified length">ProcessData</a>(outString, inString, length);
<a name="l00200"></a>00200         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (length != 0)
<a name="l00201"></a>00201                 <span class="keywordflow">throw</span> <a class="code" href="class_not_implemented.html" title="exception thrown by a class if a non-implemented method is called">NotImplemented</a>(<a class="code" href="class_algorithm.html#acd21c6715add4884fa043eaf51655039" title="returns name of this algorithm, not universally implemented yet">AlgorithmName</a>() + <span class="stringliteral">&quot;: this object does&#39;t support a special last block&quot;</span>);
<a name="l00202"></a>00202 }
<a name="l00203"></a>00203 
<a name="l00204"></a><a class="code" href="class_authenticated_symmetric_cipher.html#a7684bed45aa7e8b19de43fcb25b68c57">00204</a> <span class="keywordtype">void</span> <a class="code" href="class_authenticated_symmetric_cipher.html#a7684bed45aa7e8b19de43fcb25b68c57" title="this function only needs to be called if NeedsPrespecifiedDataLengths() returns true">AuthenticatedSymmetricCipher::SpecifyDataLengths</a>(lword headerLength, lword messageLength, lword footerLength)
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206         <span class="keywordflow">if</span> (headerLength &gt; <a class="code" href="class_authenticated_symmetric_cipher.html#a2f15306daa15eebe988df98a9c7386b0" title="the maximum length of AAD that can be input before the encrypted data">MaxHeaderLength</a>())
<a name="l00207"></a>00207                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(GetAlgorithm().<a class="code" href="class_authenticated_symmetric_cipher.html#aae9cc715b7640cfc1f5fcad980ea34a2" title="returns name of this algorithm, not universally implemented yet">AlgorithmName</a>() + <span class="stringliteral">&quot;: header length &quot;</span> + IntToString(headerLength) + <span class="stringliteral">&quot; exceeds the maximum of &quot;</span> + IntToString(<a class="code" href="class_authenticated_symmetric_cipher.html#a2f15306daa15eebe988df98a9c7386b0" title="the maximum length of AAD that can be input before the encrypted data">MaxHeaderLength</a>()));
<a name="l00208"></a>00208 
<a name="l00209"></a>00209         <span class="keywordflow">if</span> (messageLength &gt; <a class="code" href="class_authenticated_symmetric_cipher.html#a89bf90afafec009ac52321e1a97698d1" title="the maximum length of encrypted data">MaxMessageLength</a>())
<a name="l00210"></a>00210                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(GetAlgorithm().<a class="code" href="class_authenticated_symmetric_cipher.html#aae9cc715b7640cfc1f5fcad980ea34a2" title="returns name of this algorithm, not universally implemented yet">AlgorithmName</a>() + <span class="stringliteral">&quot;: message length &quot;</span> + IntToString(messageLength) + <span class="stringliteral">&quot; exceeds the maximum of &quot;</span> + IntToString(<a class="code" href="class_authenticated_symmetric_cipher.html#a89bf90afafec009ac52321e1a97698d1" title="the maximum length of encrypted data">MaxMessageLength</a>()));
<a name="l00211"></a>00211                 
<a name="l00212"></a>00212         <span class="keywordflow">if</span> (footerLength &gt; <a class="code" href="class_authenticated_symmetric_cipher.html#a2307840ae74d2c4a1cc028d4aff903b3" title="the maximum length of AAD that can be input after the encrypted data">MaxFooterLength</a>())
<a name="l00213"></a>00213                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(GetAlgorithm().<a class="code" href="class_authenticated_symmetric_cipher.html#aae9cc715b7640cfc1f5fcad980ea34a2" title="returns name of this algorithm, not universally implemented yet">AlgorithmName</a>() + <span class="stringliteral">&quot;: footer length &quot;</span> + IntToString(footerLength) + <span class="stringliteral">&quot; exceeds the maximum of &quot;</span> + IntToString(<a class="code" href="class_authenticated_symmetric_cipher.html#a2307840ae74d2c4a1cc028d4aff903b3" title="the maximum length of AAD that can be input after the encrypted data">MaxFooterLength</a>()));
<a name="l00214"></a>00214 
<a name="l00215"></a>00215         UncheckedSpecifyDataLengths(headerLength, messageLength, footerLength);
<a name="l00216"></a>00216 }
<a name="l00217"></a>00217 
<a name="l00218"></a><a class="code" href="class_authenticated_symmetric_cipher.html#a5c61b5f35b2d59c5bb4ba0df09f30e8e">00218</a> <span class="keywordtype">void</span> <a class="code" href="class_authenticated_symmetric_cipher.html#a5c61b5f35b2d59c5bb4ba0df09f30e8e" title="encrypt and generate MAC in one call. will truncate MAC if macSize &amp;lt; TagSize()">AuthenticatedSymmetricCipher::EncryptAndAuthenticate</a>(byte *ciphertext, byte *mac, <span class="keywordtype">size_t</span> macSize, <span class="keyword">const</span> byte *iv, <span class="keywordtype">int</span> ivLength, <span class="keyword">const</span> byte *header, <span class="keywordtype">size_t</span> headerLength, <span class="keyword">const</span> byte *message, <span class="keywordtype">size_t</span> messageLength)
<a name="l00219"></a>00219 {
<a name="l00220"></a>00220         <a class="code" href="class_simple_keying_interface.html#ae576137a46ca56005e82f1505cf3cccc" title="resynchronize with an IV. ivLength=-1 means use IVSize()">Resynchronize</a>(iv, ivLength);
<a name="l00221"></a>00221         <a class="code" href="class_authenticated_symmetric_cipher.html#a7684bed45aa7e8b19de43fcb25b68c57" title="this function only needs to be called if NeedsPrespecifiedDataLengths() returns true">SpecifyDataLengths</a>(headerLength, messageLength);
<a name="l00222"></a>00222         <a class="code" href="class_hash_transformation.html#aafabefaf445b65d3ba0d8e1c0294afe5" title="process more input">Update</a>(header, headerLength);
<a name="l00223"></a>00223         <a class="code" href="class_stream_transformation.html#ac00f3fcc21f33f11c8efa4de67ff7774" title="same as ProcessData(inoutString, inoutString, length)">ProcessString</a>(ciphertext, message, messageLength);
<a name="l00224"></a>00224         <a class="code" href="class_hash_transformation.html#a590ecda344aa0fb045abf42ec08823b2" title="truncated version of Final()">TruncatedFinal</a>(mac, macSize);
<a name="l00225"></a>00225 }
<a name="l00226"></a>00226 
<a name="l00227"></a><a class="code" href="class_authenticated_symmetric_cipher.html#abde6e617e4ec3fa9d6186dd7782d7437">00227</a> <span class="keywordtype">bool</span> <a class="code" href="class_authenticated_symmetric_cipher.html#abde6e617e4ec3fa9d6186dd7782d7437" title="decrypt and verify MAC in one call, returning true iff MAC is valid. will assume MAC is truncated if ...">AuthenticatedSymmetricCipher::DecryptAndVerify</a>(byte *message, <span class="keyword">const</span> byte *mac, <span class="keywordtype">size_t</span> macLength, <span class="keyword">const</span> byte *iv, <span class="keywordtype">int</span> ivLength, <span class="keyword">const</span> byte *header, <span class="keywordtype">size_t</span> headerLength, <span class="keyword">const</span> byte *ciphertext, <span class="keywordtype">size_t</span> ciphertextLength)
<a name="l00228"></a>00228 {
<a name="l00229"></a>00229         <a class="code" href="class_simple_keying_interface.html#ae576137a46ca56005e82f1505cf3cccc" title="resynchronize with an IV. ivLength=-1 means use IVSize()">Resynchronize</a>(iv, ivLength);
<a name="l00230"></a>00230         <a class="code" href="class_authenticated_symmetric_cipher.html#a7684bed45aa7e8b19de43fcb25b68c57" title="this function only needs to be called if NeedsPrespecifiedDataLengths() returns true">SpecifyDataLengths</a>(headerLength, ciphertextLength);
<a name="l00231"></a>00231         <a class="code" href="class_hash_transformation.html#aafabefaf445b65d3ba0d8e1c0294afe5" title="process more input">Update</a>(header, headerLength);
<a name="l00232"></a>00232         <a class="code" href="class_stream_transformation.html#ac00f3fcc21f33f11c8efa4de67ff7774" title="same as ProcessData(inoutString, inoutString, length)">ProcessString</a>(message, ciphertext, ciphertextLength);
<a name="l00233"></a>00233         <span class="keywordflow">return</span> <a class="code" href="class_hash_transformation.html#a0f6069eadf492d970c3eb8cdf656e742" title="truncated version of Verify()">TruncatedVerify</a>(mac, macLength);
<a name="l00234"></a>00234 }
<a name="l00235"></a>00235 
<a name="l00236"></a><a class="code" href="class_random_number_generator.html#ace592244cfbd6c18398ea6c75857532e">00236</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_random_number_generator.html#ace592244cfbd6c18398ea6c75857532e" title="generate new random bit and return it">RandomNumberGenerator::GenerateBit</a>()
<a name="l00237"></a>00237 {
<a name="l00238"></a>00238         <span class="keywordflow">return</span> <a class="code" href="class_random_number_generator.html#ada0f7c437b0c8e6ba94ebcd75bff4bda" title="generate new random byte and return it">GenerateByte</a>() &amp; 1;
<a name="l00239"></a>00239 }
<a name="l00240"></a>00240 
<a name="l00241"></a><a class="code" href="class_random_number_generator.html#ada0f7c437b0c8e6ba94ebcd75bff4bda">00241</a> byte <a class="code" href="class_random_number_generator.html#ada0f7c437b0c8e6ba94ebcd75bff4bda" title="generate new random byte and return it">RandomNumberGenerator::GenerateByte</a>()
<a name="l00242"></a>00242 {
<a name="l00243"></a>00243         byte b;
<a name="l00244"></a>00244         <a class="code" href="class_random_number_generator.html#a497145546d24e6d4abaf10b7e0f1ba17" title="generate random array of bytes">GenerateBlock</a>(&amp;b, 1);
<a name="l00245"></a>00245         <span class="keywordflow">return</span> b;
<a name="l00246"></a>00246 }
<a name="l00247"></a>00247 
<a name="l00248"></a><a class="code" href="class_random_number_generator.html#ac06c9f5e66f35d643e4192f231b8a4cd">00248</a> word32 <a class="code" href="class_random_number_generator.html#ac06c9f5e66f35d643e4192f231b8a4cd" title="generate a random 32 bit word in the range min to max, inclusive">RandomNumberGenerator::GenerateWord32</a>(word32 min, word32 max)
<a name="l00249"></a>00249 {
<a name="l00250"></a>00250         word32 range = max-min;
<a name="l00251"></a>00251         <span class="keyword">const</span> <span class="keywordtype">int</span> maxBits = BitPrecision(range);
<a name="l00252"></a>00252 
<a name="l00253"></a>00253         word32 value;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255         <span class="keywordflow">do</span>
<a name="l00256"></a>00256         {
<a name="l00257"></a>00257                 <a class="code" href="class_random_number_generator.html#a497145546d24e6d4abaf10b7e0f1ba17" title="generate random array of bytes">GenerateBlock</a>((byte *)&amp;value, <span class="keyword">sizeof</span>(value));
<a name="l00258"></a>00258                 value = Crop(value, maxBits);
<a name="l00259"></a>00259         } <span class="keywordflow">while</span> (value &gt; range);
<a name="l00260"></a>00260 
<a name="l00261"></a>00261         <span class="keywordflow">return</span> value+min;
<a name="l00262"></a>00262 }
<a name="l00263"></a>00263 
<a name="l00264"></a><a class="code" href="class_random_number_generator.html#a497145546d24e6d4abaf10b7e0f1ba17">00264</a> <span class="keywordtype">void</span> <a class="code" href="class_random_number_generator.html#a497145546d24e6d4abaf10b7e0f1ba17" title="generate random array of bytes">RandomNumberGenerator::GenerateBlock</a>(byte *output, <span class="keywordtype">size_t</span> size)
<a name="l00265"></a>00265 {
<a name="l00266"></a>00266         <a class="code" href="class_array_sink.html" title="Copy input to a memory buffer.">ArraySink</a> s(output, size);
<a name="l00267"></a>00267         <a class="code" href="class_random_number_generator.html#a5cc474006e2c7383ec20cc4d0c2abbaf" title="generate random bytes as input to a BufferedTransformation">GenerateIntoBufferedTransformation</a>(s, DEFAULT_CHANNEL, size);
<a name="l00268"></a>00268 }
<a name="l00269"></a>00269 
<a name="l00270"></a><a class="code" href="class_random_number_generator.html#a44f70ad8fed869a4ee55f50ef8e6e699">00270</a> <span class="keywordtype">void</span> <a class="code" href="class_random_number_generator.html#a44f70ad8fed869a4ee55f50ef8e6e699" title="generate and discard n bytes">RandomNumberGenerator::DiscardBytes</a>(<span class="keywordtype">size_t</span> n)
<a name="l00271"></a>00271 {
<a name="l00272"></a>00272         <a class="code" href="class_random_number_generator.html#a5cc474006e2c7383ec20cc4d0c2abbaf" title="generate random bytes as input to a BufferedTransformation">GenerateIntoBufferedTransformation</a>(TheBitBucket(), DEFAULT_CHANNEL, n);
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 
<a name="l00275"></a><a class="code" href="class_random_number_generator.html#a5cc474006e2c7383ec20cc4d0c2abbaf">00275</a> <span class="keywordtype">void</span> <a class="code" href="class_random_number_generator.html#a5cc474006e2c7383ec20cc4d0c2abbaf" title="generate random bytes as input to a BufferedTransformation">RandomNumberGenerator::GenerateIntoBufferedTransformation</a>(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;target, <span class="keyword">const</span> std::string &amp;channel, lword length)
<a name="l00276"></a>00276 {
<a name="l00277"></a>00277         <a class="code" href="class_fixed_size_sec_block.html">FixedSizeSecBlock&lt;byte, 256&gt;</a> buffer;
<a name="l00278"></a>00278         <span class="keywordflow">while</span> (length)
<a name="l00279"></a>00279         {
<a name="l00280"></a>00280                 <span class="keywordtype">size_t</span> len = UnsignedMin(buffer.size(), length);
<a name="l00281"></a>00281                 <a class="code" href="class_random_number_generator.html#a497145546d24e6d4abaf10b7e0f1ba17" title="generate random array of bytes">GenerateBlock</a>(buffer, len);
<a name="l00282"></a>00282                 target.ChannelPut(channel, buffer, len);
<a name="l00283"></a>00283                 length -= len;
<a name="l00284"></a>00284         }
<a name="l00285"></a>00285 }
<a name="l00286"></a>00286 <span class="comment"></span>
<a name="l00287"></a>00287 <span class="comment">//! see NullRNG()</span>
<a name="l00288"></a><a class="code" href="class_class_null_r_n_g.html">00288</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_class_null_r_n_g.html" title="see NullRNG()">ClassNullRNG</a> : <span class="keyword">public</span> <a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a>
<a name="l00289"></a>00289 {
<a name="l00290"></a>00290 <span class="keyword">public</span>:
<a name="l00291"></a><a class="code" href="class_class_null_r_n_g.html#a5490c3eb043c84f685a0f45fbf4a96af">00291</a>         std::string <a class="code" href="class_class_null_r_n_g.html#a5490c3eb043c84f685a0f45fbf4a96af" title="returns name of this algorithm, not universally implemented yet">AlgorithmName</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> <span class="stringliteral">&quot;NullRNG&quot;</span>;}
<a name="l00292"></a><a class="code" href="class_class_null_r_n_g.html#a3fe959f398f36e108f2ba3e57f17644f">00292</a>         <span class="keywordtype">void</span> <a class="code" href="class_class_null_r_n_g.html#a3fe959f398f36e108f2ba3e57f17644f" title="generate random array of bytes">GenerateBlock</a>(byte *output, <span class="keywordtype">size_t</span> size) {<span class="keywordflow">throw</span> <a class="code" href="class_not_implemented.html" title="exception thrown by a class if a non-implemented method is called">NotImplemented</a>(<span class="stringliteral">&quot;NullRNG: NullRNG should only be passed to functions that don&#39;t need to generate random bytes&quot;</span>);}
<a name="l00293"></a>00293 };
<a name="l00294"></a>00294 
<a name="l00295"></a><a class="code" href="cryptlib_8h.html#a1e53479a6d427158247ac1ece3161a6d">00295</a> <a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp; NullRNG()
<a name="l00296"></a>00296 {
<a name="l00297"></a>00297         <span class="keyword">static</span> <a class="code" href="class_class_null_r_n_g.html" title="see NullRNG()">ClassNullRNG</a> s_nullRNG;
<a name="l00298"></a>00298         <span class="keywordflow">return</span> s_nullRNG;
<a name="l00299"></a>00299 }
<a name="l00300"></a>00300 
<a name="l00301"></a><a class="code" href="class_hash_transformation.html#a0f6069eadf492d970c3eb8cdf656e742">00301</a> <span class="keywordtype">bool</span> <a class="code" href="class_hash_transformation.html#a0f6069eadf492d970c3eb8cdf656e742" title="truncated version of Verify()">HashTransformation::TruncatedVerify</a>(<span class="keyword">const</span> byte *digestIn, <span class="keywordtype">size_t</span> digestLength)
<a name="l00302"></a>00302 {
<a name="l00303"></a>00303         ThrowIfInvalidTruncatedSize(digestLength);
<a name="l00304"></a>00304         <a class="code" href="class_sec_block.html">SecByteBlock</a> digest(digestLength);
<a name="l00305"></a>00305         <a class="code" href="class_hash_transformation.html#a590ecda344aa0fb045abf42ec08823b2" title="truncated version of Final()">TruncatedFinal</a>(digest, digestLength);
<a name="l00306"></a>00306         <span class="keywordflow">return</span> VerifyBufsEqual(digest, digestIn, digestLength);
<a name="l00307"></a>00307 }
<a name="l00308"></a>00308 
<a name="l00309"></a>00309 <span class="keywordtype">void</span> HashTransformation::ThrowIfInvalidTruncatedSize(<span class="keywordtype">size_t</span> size)<span class="keyword"> const</span>
<a name="l00310"></a>00310 <span class="keyword"></span>{
<a name="l00311"></a>00311         <span class="keywordflow">if</span> (size &gt; <a class="code" href="class_hash_transformation.html#a9f42cc280bac76b884ad12615c0dabb5" title="size of the hash/digest/MAC returned by Final()">DigestSize</a>())
<a name="l00312"></a>00312                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(<span class="stringliteral">&quot;HashTransformation: can&#39;t truncate a &quot;</span> + IntToString(<a class="code" href="class_hash_transformation.html#a9f42cc280bac76b884ad12615c0dabb5" title="size of the hash/digest/MAC returned by Final()">DigestSize</a>()) + <span class="stringliteral">&quot; byte digest to &quot;</span> + IntToString(size) + <span class="stringliteral">&quot; bytes&quot;</span>);
<a name="l00313"></a>00313 }
<a name="l00314"></a>00314 
<a name="l00315"></a><a class="code" href="class_buffered_transformation.html#a99cd939cda477af4d8e09bf15c692dc2">00315</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_buffered_transformation.html#a99cd939cda477af4d8e09bf15c692dc2" title="maximum number of wait objects that this object can return">BufferedTransformation::GetMaxWaitObjectCount</a>()<span class="keyword"> const</span>
<a name="l00316"></a>00316 <span class="keyword"></span>{
<a name="l00317"></a>00317         <span class="keyword">const</span> <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *t = <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>();
<a name="l00318"></a>00318         <span class="keywordflow">return</span> t ? t-&gt;<a class="code" href="class_buffered_transformation.html#a99cd939cda477af4d8e09bf15c692dc2" title="maximum number of wait objects that this object can return">GetMaxWaitObjectCount</a>() : 0;
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 
<a name="l00321"></a><a class="code" href="class_buffered_transformation.html#a127ccd1793fdda6548cd1295f848d0f7">00321</a> <span class="keywordtype">void</span> <a class="code" href="class_buffered_transformation.html#a127ccd1793fdda6548cd1295f848d0f7" title="put wait objects into container">BufferedTransformation::GetWaitObjects</a>(<a class="code" href="class_wait_object_container.html" title="container of wait objects">WaitObjectContainer</a> &amp;container, <a class="code" href="class_call_stack.html">CallStack</a> <span class="keyword">const</span>&amp; callStack)
<a name="l00322"></a>00322 {
<a name="l00323"></a>00323         <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *t = <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>();
<a name="l00324"></a>00324         <span class="keywordflow">if</span> (t)
<a name="l00325"></a>00325                 t-&gt;<a class="code" href="class_buffered_transformation.html#a127ccd1793fdda6548cd1295f848d0f7" title="put wait objects into container">GetWaitObjects</a>(container, callStack);  <span class="comment">// reduce clutter by not adding to stack here</span>
<a name="l00326"></a>00326 }
<a name="l00327"></a>00327 
<a name="l00328"></a><a class="code" href="class_buffered_transformation.html#a0dd5456c06e0e47d901e8055b50df929">00328</a> <span class="keywordtype">void</span> <a class="code" href="class_buffered_transformation.html#a0dd5456c06e0e47d901e8055b50df929" title="initialize or reinitialize this object">BufferedTransformation::Initialize</a>(<span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;parameters, <span class="keywordtype">int</span> propagation)
<a name="l00329"></a>00329 {
<a name="l00330"></a>00330         assert(!<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>());
<a name="l00331"></a>00331         IsolatedInitialize(parameters);
<a name="l00332"></a>00332 }
<a name="l00333"></a>00333 
<a name="l00334"></a><a class="code" href="class_buffered_transformation.html#a8a62b1b6c8f310363f32b05b20c306eb">00334</a> <span class="keywordtype">bool</span> <a class="code" href="class_buffered_transformation.html#a8a62b1b6c8f310363f32b05b20c306eb" title="flush buffered input and/or output">BufferedTransformation::Flush</a>(<span class="keywordtype">bool</span> hardFlush, <span class="keywordtype">int</span> propagation, <span class="keywordtype">bool</span> blocking)
<a name="l00335"></a>00335 {
<a name="l00336"></a>00336         assert(!<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>());
<a name="l00337"></a>00337         <span class="keywordflow">return</span> IsolatedFlush(hardFlush, blocking);
<a name="l00338"></a>00338 }
<a name="l00339"></a>00339 
<a name="l00340"></a><a class="code" href="class_buffered_transformation.html#aae4c5ae024419e31bfa0c24eb35b24c2">00340</a> <span class="keywordtype">bool</span> <a class="code" href="class_buffered_transformation.html#aae4c5ae024419e31bfa0c24eb35b24c2" title="mark end of a series of messages">BufferedTransformation::MessageSeriesEnd</a>(<span class="keywordtype">int</span> propagation, <span class="keywordtype">bool</span> blocking)
<a name="l00341"></a>00341 {
<a name="l00342"></a>00342         assert(!<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>());
<a name="l00343"></a>00343         <span class="keywordflow">return</span> IsolatedMessageSeriesEnd(blocking);
<a name="l00344"></a>00344 }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 byte * BufferedTransformation::ChannelCreatePutSpace(<span class="keyword">const</span> std::string &amp;channel, <span class="keywordtype">size_t</span> &amp;size)
<a name="l00347"></a>00347 {
<a name="l00348"></a>00348         <span class="keywordflow">if</span> (channel.empty())
<a name="l00349"></a>00349                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#af390325c959c3d6a2c03a447d6cd469d" title="request space which can be written into by the caller, and then used as input to Put()">CreatePutSpace</a>(size);
<a name="l00350"></a>00350         <span class="keywordflow">else</span>
<a name="l00351"></a>00351                 <span class="keywordflow">throw</span> NoChannelSupport(<a class="code" href="class_algorithm.html#acd21c6715add4884fa043eaf51655039" title="returns name of this algorithm, not universally implemented yet">AlgorithmName</a>());
<a name="l00352"></a>00352 }
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 <span class="keywordtype">size_t</span> BufferedTransformation::ChannelPut2(<span class="keyword">const</span> std::string &amp;channel, <span class="keyword">const</span> byte *begin, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> messageEnd, <span class="keywordtype">bool</span> blocking)
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356         <span class="keywordflow">if</span> (channel.empty())
<a name="l00357"></a>00357                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ad396dcb42260f23125a35ec0e5d17d55" title="input multiple bytes for blocking or non-blocking processing">Put2</a>(begin, length, messageEnd, blocking);
<a name="l00358"></a>00358         <span class="keywordflow">else</span>
<a name="l00359"></a>00359                 <span class="keywordflow">throw</span> NoChannelSupport(<a class="code" href="class_algorithm.html#acd21c6715add4884fa043eaf51655039" title="returns name of this algorithm, not universally implemented yet">AlgorithmName</a>());
<a name="l00360"></a>00360 }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="keywordtype">size_t</span> BufferedTransformation::ChannelPutModifiable2(<span class="keyword">const</span> std::string &amp;channel, byte *begin, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> messageEnd, <span class="keywordtype">bool</span> blocking)
<a name="l00363"></a>00363 {
<a name="l00364"></a>00364         <span class="keywordflow">if</span> (channel.empty())
<a name="l00365"></a>00365                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#a770bf11f26d4dec66423a7dc2d36843d" title="input multiple bytes that may be modified by callee for blocking or non-blocking processing">PutModifiable2</a>(begin, length, messageEnd, blocking);
<a name="l00366"></a>00366         <span class="keywordflow">else</span>
<a name="l00367"></a>00367                 <span class="keywordflow">return</span> ChannelPut2(channel, begin, length, messageEnd, blocking);
<a name="l00368"></a>00368 }
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 <span class="keywordtype">bool</span> BufferedTransformation::ChannelFlush(<span class="keyword">const</span> std::string &amp;channel, <span class="keywordtype">bool</span> completeFlush, <span class="keywordtype">int</span> propagation, <span class="keywordtype">bool</span> blocking)
<a name="l00371"></a>00371 {
<a name="l00372"></a>00372         <span class="keywordflow">if</span> (channel.empty())
<a name="l00373"></a>00373                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#a8a62b1b6c8f310363f32b05b20c306eb" title="flush buffered input and/or output">Flush</a>(completeFlush, propagation, blocking);
<a name="l00374"></a>00374         <span class="keywordflow">else</span>
<a name="l00375"></a>00375                 <span class="keywordflow">throw</span> NoChannelSupport(<a class="code" href="class_algorithm.html#acd21c6715add4884fa043eaf51655039" title="returns name of this algorithm, not universally implemented yet">AlgorithmName</a>());
<a name="l00376"></a>00376 }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="keywordtype">bool</span> BufferedTransformation::ChannelMessageSeriesEnd(<span class="keyword">const</span> std::string &amp;channel, <span class="keywordtype">int</span> propagation, <span class="keywordtype">bool</span> blocking)
<a name="l00379"></a>00379 {
<a name="l00380"></a>00380         <span class="keywordflow">if</span> (channel.empty())
<a name="l00381"></a>00381                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aae4c5ae024419e31bfa0c24eb35b24c2" title="mark end of a series of messages">MessageSeriesEnd</a>(propagation, blocking);
<a name="l00382"></a>00382         <span class="keywordflow">else</span>
<a name="l00383"></a>00383                 <span class="keywordflow">throw</span> NoChannelSupport(<a class="code" href="class_algorithm.html#acd21c6715add4884fa043eaf51655039" title="returns name of this algorithm, not universally implemented yet">AlgorithmName</a>());
<a name="l00384"></a>00384 }
<a name="l00385"></a>00385 
<a name="l00386"></a><a class="code" href="class_buffered_transformation.html#a6ec48acd2d2bda08baa4baa1c9a8a99c">00386</a> lword <a class="code" href="class_buffered_transformation.html#a6ec48acd2d2bda08baa4baa1c9a8a99c" title="returns number of bytes that is currently ready for retrieval">BufferedTransformation::MaxRetrievable</a>()<span class="keyword"> const</span>
<a name="l00387"></a>00387 <span class="keyword"></span>{
<a name="l00388"></a>00388         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00389"></a>00389                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a6ec48acd2d2bda08baa4baa1c9a8a99c" title="returns number of bytes that is currently ready for retrieval">MaxRetrievable</a>();
<a name="l00390"></a>00390         <span class="keywordflow">else</span>
<a name="l00391"></a>00391                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#a5253b8693ac9932f3862b71c9960903c" title="copy copyMax bytes of the buffered output to target as input">CopyTo</a>(TheBitBucket());
<a name="l00392"></a>00392 }
<a name="l00393"></a>00393 
<a name="l00394"></a><a class="code" href="class_buffered_transformation.html#ad5ee1b2a57700142f9c51e5a94703fc2">00394</a> <span class="keywordtype">bool</span> <a class="code" href="class_buffered_transformation.html#ad5ee1b2a57700142f9c51e5a94703fc2" title="returns whether any bytes are currently ready for retrieval">BufferedTransformation::AnyRetrievable</a>()<span class="keyword"> const</span>
<a name="l00395"></a>00395 <span class="keyword"></span>{
<a name="l00396"></a>00396         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00397"></a>00397                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#ad5ee1b2a57700142f9c51e5a94703fc2" title="returns whether any bytes are currently ready for retrieval">AnyRetrievable</a>();
<a name="l00398"></a>00398         <span class="keywordflow">else</span>
<a name="l00399"></a>00399         {
<a name="l00400"></a>00400                 byte b;
<a name="l00401"></a>00401                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#a5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">Peek</a>(b) != 0;
<a name="l00402"></a>00402         }
<a name="l00403"></a>00403 }
<a name="l00404"></a>00404 
<a name="l00405"></a><a class="code" href="class_buffered_transformation.html#a9e1ad913c8fe697d269f408a7d5928fc">00405</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#a9e1ad913c8fe697d269f408a7d5928fc" title="try to retrieve a single byte">BufferedTransformation::Get</a>(byte &amp;outByte)
<a name="l00406"></a>00406 {
<a name="l00407"></a>00407         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00408"></a>00408                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a9e1ad913c8fe697d269f408a7d5928fc" title="try to retrieve a single byte">Get</a>(outByte);
<a name="l00409"></a>00409         <span class="keywordflow">else</span>
<a name="l00410"></a>00410                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#a9e1ad913c8fe697d269f408a7d5928fc" title="try to retrieve a single byte">Get</a>(&amp;outByte, 1);
<a name="l00411"></a>00411 }
<a name="l00412"></a>00412 
<a name="l00413"></a><a class="code" href="class_buffered_transformation.html#a0a6f18a871720453e1791c64f0461a9f">00413</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#a9e1ad913c8fe697d269f408a7d5928fc" title="try to retrieve a single byte">BufferedTransformation::Get</a>(byte *outString, <span class="keywordtype">size_t</span> getMax)
<a name="l00414"></a>00414 {
<a name="l00415"></a>00415         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00416"></a>00416                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a9e1ad913c8fe697d269f408a7d5928fc" title="try to retrieve a single byte">Get</a>(outString, getMax);
<a name="l00417"></a>00417         <span class="keywordflow">else</span>
<a name="l00418"></a>00418         {
<a name="l00419"></a>00419                 <a class="code" href="class_array_sink.html" title="Copy input to a memory buffer.">ArraySink</a> arraySink(outString, getMax);
<a name="l00420"></a>00420                 <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)<a class="code" href="class_buffered_transformation.html#ac31ac5d2da7897fb097086496b85e6f5" title="move transferMax bytes of the buffered output to target as input">TransferTo</a>(arraySink, getMax);
<a name="l00421"></a>00421         }
<a name="l00422"></a>00422 }
<a name="l00423"></a>00423 
<a name="l00424"></a><a class="code" href="class_buffered_transformation.html#a5fa048faf8c043ad57ae0a8911070090">00424</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#a5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">BufferedTransformation::Peek</a>(byte &amp;outByte)<span class="keyword"> const</span>
<a name="l00425"></a>00425 <span class="keyword"></span>{
<a name="l00426"></a>00426         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00427"></a>00427                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">Peek</a>(outByte);
<a name="l00428"></a>00428         <span class="keywordflow">else</span>
<a name="l00429"></a>00429                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#a5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">Peek</a>(&amp;outByte, 1);
<a name="l00430"></a>00430 }
<a name="l00431"></a>00431 
<a name="l00432"></a><a class="code" href="class_buffered_transformation.html#aacdeedab8dc8557d17b12b67a9ff94dc">00432</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#a5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">BufferedTransformation::Peek</a>(byte *outString, <span class="keywordtype">size_t</span> peekMax)<span class="keyword"> const</span>
<a name="l00433"></a>00433 <span class="keyword"></span>{
<a name="l00434"></a>00434         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00435"></a>00435                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">Peek</a>(outString, peekMax);
<a name="l00436"></a>00436         <span class="keywordflow">else</span>
<a name="l00437"></a>00437         {
<a name="l00438"></a>00438                 <a class="code" href="class_array_sink.html" title="Copy input to a memory buffer.">ArraySink</a> arraySink(outString, peekMax);
<a name="l00439"></a>00439                 <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)<a class="code" href="class_buffered_transformation.html#a5253b8693ac9932f3862b71c9960903c" title="copy copyMax bytes of the buffered output to target as input">CopyTo</a>(arraySink, peekMax);
<a name="l00440"></a>00440         }
<a name="l00441"></a>00441 }
<a name="l00442"></a>00442 
<a name="l00443"></a><a class="code" href="class_buffered_transformation.html#a0c25529ded99db20ad35ccef3f7234e6">00443</a> lword <a class="code" href="class_buffered_transformation.html#a0c25529ded99db20ad35ccef3f7234e6" title="discard skipMax bytes from the output buffer">BufferedTransformation::Skip</a>(lword skipMax)
<a name="l00444"></a>00444 {
<a name="l00445"></a>00445         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00446"></a>00446                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a0c25529ded99db20ad35ccef3f7234e6" title="discard skipMax bytes from the output buffer">Skip</a>(skipMax);
<a name="l00447"></a>00447         <span class="keywordflow">else</span>
<a name="l00448"></a>00448                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#ac31ac5d2da7897fb097086496b85e6f5" title="move transferMax bytes of the buffered output to target as input">TransferTo</a>(TheBitBucket(), skipMax);
<a name="l00449"></a>00449 }
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 lword BufferedTransformation::TotalBytesRetrievable()<span class="keyword"> const</span>
<a name="l00452"></a>00452 <span class="keyword"></span>{
<a name="l00453"></a>00453         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00454"></a>00454                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;TotalBytesRetrievable();
<a name="l00455"></a>00455         <span class="keywordflow">else</span>
<a name="l00456"></a>00456                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#a6ec48acd2d2bda08baa4baa1c9a8a99c" title="returns number of bytes that is currently ready for retrieval">MaxRetrievable</a>();
<a name="l00457"></a>00457 }
<a name="l00458"></a>00458 
<a name="l00459"></a><a class="code" href="class_buffered_transformation.html#a318ef5010ac587977656dae56dfc5085">00459</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_buffered_transformation.html#a318ef5010ac587977656dae56dfc5085" title="number of times MessageEnd() has been received minus messages retrieved or skipped">BufferedTransformation::NumberOfMessages</a>()<span class="keyword"> const</span>
<a name="l00460"></a>00460 <span class="keyword"></span>{
<a name="l00461"></a>00461         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00462"></a>00462                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a318ef5010ac587977656dae56dfc5085" title="number of times MessageEnd() has been received minus messages retrieved or skipped">NumberOfMessages</a>();
<a name="l00463"></a>00463         <span class="keywordflow">else</span>
<a name="l00464"></a>00464                 <span class="keywordflow">return</span> CopyMessagesTo(TheBitBucket());
<a name="l00465"></a>00465 }
<a name="l00466"></a>00466 
<a name="l00467"></a><a class="code" href="class_buffered_transformation.html#a76b40ce3c88455c69f06234d609a0e4c">00467</a> <span class="keywordtype">bool</span> <a class="code" href="class_buffered_transformation.html#a76b40ce3c88455c69f06234d609a0e4c" title="returns true if NumberOfMessages() &amp;gt; 0">BufferedTransformation::AnyMessages</a>()<span class="keyword"> const</span>
<a name="l00468"></a>00468 <span class="keyword"></span>{
<a name="l00469"></a>00469         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00470"></a>00470                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a76b40ce3c88455c69f06234d609a0e4c" title="returns true if NumberOfMessages() &amp;gt; 0">AnyMessages</a>();
<a name="l00471"></a>00471         <span class="keywordflow">else</span>
<a name="l00472"></a>00472                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#a318ef5010ac587977656dae56dfc5085" title="number of times MessageEnd() has been received minus messages retrieved or skipped">NumberOfMessages</a>() != 0;
<a name="l00473"></a>00473 }
<a name="l00474"></a>00474 
<a name="l00475"></a><a class="code" href="class_buffered_transformation.html#a8dc8562950fd563f7c62d1f1e5ec6b1e">00475</a> <span class="keywordtype">bool</span> <a class="code" href="class_buffered_transformation.html#a8dc8562950fd563f7c62d1f1e5ec6b1e" title="start retrieving the next message">BufferedTransformation::GetNextMessage</a>()
<a name="l00476"></a>00476 {
<a name="l00477"></a>00477         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00478"></a>00478                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a8dc8562950fd563f7c62d1f1e5ec6b1e" title="start retrieving the next message">GetNextMessage</a>();
<a name="l00479"></a>00479         <span class="keywordflow">else</span>
<a name="l00480"></a>00480         {
<a name="l00481"></a>00481                 assert(!<a class="code" href="class_buffered_transformation.html#a76b40ce3c88455c69f06234d609a0e4c" title="returns true if NumberOfMessages() &amp;gt; 0">AnyMessages</a>());
<a name="l00482"></a>00482                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00483"></a>00483         }
<a name="l00484"></a>00484 }
<a name="l00485"></a>00485 
<a name="l00486"></a><a class="code" href="class_buffered_transformation.html#ace560f14489f478bb4cd17c41905774e">00486</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="class_buffered_transformation.html#ace560f14489f478bb4cd17c41905774e" title="skip count number of messages">BufferedTransformation::SkipMessages</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count)
<a name="l00487"></a>00487 {
<a name="l00488"></a>00488         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00489"></a>00489                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#ace560f14489f478bb4cd17c41905774e" title="skip count number of messages">SkipMessages</a>(count);
<a name="l00490"></a>00490         <span class="keywordflow">else</span>
<a name="l00491"></a>00491                 <span class="keywordflow">return</span> TransferMessagesTo(TheBitBucket(), count);
<a name="l00492"></a>00492 }
<a name="l00493"></a>00493 
<a name="l00494"></a><a class="code" href="class_buffered_transformation.html#a1a70058989762156c376d7ffa5cb303e">00494</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#a1a70058989762156c376d7ffa5cb303e" title="upon return, messageCount contains number of messages that have finished being transfered, and returns the number of bytes left in the current transfer block">BufferedTransformation::TransferMessagesTo2</a>(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;target, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;messageCount, <span class="keyword">const</span> std::string &amp;channel, <span class="keywordtype">bool</span> blocking)
<a name="l00495"></a>00495 {
<a name="l00496"></a>00496         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00497"></a>00497                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a1a70058989762156c376d7ffa5cb303e" title="upon return, messageCount contains number of messages that have finished being transfered, and returns the number of bytes left in the current transfer block">TransferMessagesTo2</a>(target, messageCount, channel, blocking);
<a name="l00498"></a>00498         <span class="keywordflow">else</span>
<a name="l00499"></a>00499         {
<a name="l00500"></a>00500                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxMessages = messageCount;
<a name="l00501"></a>00501                 <span class="keywordflow">for</span> (messageCount=0; messageCount &lt; maxMessages &amp;&amp; <a class="code" href="class_buffered_transformation.html#a76b40ce3c88455c69f06234d609a0e4c" title="returns true if NumberOfMessages() &amp;gt; 0">AnyMessages</a>(); messageCount++)
<a name="l00502"></a>00502                 {
<a name="l00503"></a>00503                         <span class="keywordtype">size_t</span> blockedBytes;
<a name="l00504"></a>00504                         lword transferredBytes;
<a name="l00505"></a>00505 
<a name="l00506"></a>00506                         <span class="keywordflow">while</span> (<a class="code" href="class_buffered_transformation.html#ad5ee1b2a57700142f9c51e5a94703fc2" title="returns whether any bytes are currently ready for retrieval">AnyRetrievable</a>())
<a name="l00507"></a>00507                         {
<a name="l00508"></a>00508                                 transferredBytes = LWORD_MAX;
<a name="l00509"></a>00509                                 blockedBytes = <a class="code" href="class_buffered_transformation.html#a27ac15af3ef43c5ad1e9db5812025fcd" title="upon return, byteCount contains number of bytes that have finished being transfered, and returns the number of bytes left in the current transfer block">TransferTo2</a>(target, transferredBytes, channel, blocking);
<a name="l00510"></a>00510                                 <span class="keywordflow">if</span> (blockedBytes &gt; 0)
<a name="l00511"></a>00511                                         <span class="keywordflow">return</span> blockedBytes;
<a name="l00512"></a>00512                         }
<a name="l00513"></a>00513 
<a name="l00514"></a>00514                         <span class="keywordflow">if</span> (target.ChannelMessageEnd(channel, GetAutoSignalPropagation(), blocking))
<a name="l00515"></a>00515                                 <span class="keywordflow">return</span> 1;
<a name="l00516"></a>00516 
<a name="l00517"></a>00517                         <span class="keywordtype">bool</span> result = <a class="code" href="class_buffered_transformation.html#a8dc8562950fd563f7c62d1f1e5ec6b1e" title="start retrieving the next message">GetNextMessage</a>();
<a name="l00518"></a>00518                         assert(result);
<a name="l00519"></a>00519                 }
<a name="l00520"></a>00520                 <span class="keywordflow">return</span> 0;
<a name="l00521"></a>00521         }
<a name="l00522"></a>00522 }
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> BufferedTransformation::CopyMessagesTo(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;target, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> count, <span class="keyword">const</span> std::string &amp;channel)<span class="keyword"> const</span>
<a name="l00525"></a>00525 <span class="keyword"></span>{
<a name="l00526"></a>00526         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00527"></a>00527                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;CopyMessagesTo(target, count, channel);
<a name="l00528"></a>00528         <span class="keywordflow">else</span>
<a name="l00529"></a>00529                 <span class="keywordflow">return</span> 0;
<a name="l00530"></a>00530 }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532 <span class="keywordtype">void</span> BufferedTransformation::SkipAll()
<a name="l00533"></a>00533 {
<a name="l00534"></a>00534         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00535"></a>00535                 <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;SkipAll();
<a name="l00536"></a>00536         <span class="keywordflow">else</span>
<a name="l00537"></a>00537         {
<a name="l00538"></a>00538                 <span class="keywordflow">while</span> (<a class="code" href="class_buffered_transformation.html#ace560f14489f478bb4cd17c41905774e" title="skip count number of messages">SkipMessages</a>()) {}
<a name="l00539"></a>00539                 <span class="keywordflow">while</span> (<a class="code" href="class_buffered_transformation.html#a0c25529ded99db20ad35ccef3f7234e6" title="discard skipMax bytes from the output buffer">Skip</a>()) {}
<a name="l00540"></a>00540         }
<a name="l00541"></a>00541 }
<a name="l00542"></a>00542 
<a name="l00543"></a><a class="code" href="class_buffered_transformation.html#a3e47718aa65674256e1b069ec8e706b7">00543</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#a3e47718aa65674256e1b069ec8e706b7" title="returns the number of bytes left in the current transfer block">BufferedTransformation::TransferAllTo2</a>(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;target, <span class="keyword">const</span> std::string &amp;channel, <span class="keywordtype">bool</span> blocking)
<a name="l00544"></a>00544 {
<a name="l00545"></a>00545         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00546"></a>00546                 <span class="keywordflow">return</span> <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a3e47718aa65674256e1b069ec8e706b7" title="returns the number of bytes left in the current transfer block">TransferAllTo2</a>(target, channel, blocking);
<a name="l00547"></a>00547         <span class="keywordflow">else</span>
<a name="l00548"></a>00548         {
<a name="l00549"></a>00549                 assert(!NumberOfMessageSeries());
<a name="l00550"></a>00550 
<a name="l00551"></a>00551                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> messageCount;
<a name="l00552"></a>00552                 <span class="keywordflow">do</span>
<a name="l00553"></a>00553                 {
<a name="l00554"></a>00554                         messageCount = UINT_MAX;
<a name="l00555"></a>00555                         <span class="keywordtype">size_t</span> blockedBytes = <a class="code" href="class_buffered_transformation.html#a1a70058989762156c376d7ffa5cb303e" title="upon return, messageCount contains number of messages that have finished being transfered, and returns the number of bytes left in the current transfer block">TransferMessagesTo2</a>(target, messageCount, channel, blocking);
<a name="l00556"></a>00556                         <span class="keywordflow">if</span> (blockedBytes)
<a name="l00557"></a>00557                                 <span class="keywordflow">return</span> blockedBytes;
<a name="l00558"></a>00558                 }
<a name="l00559"></a>00559                 <span class="keywordflow">while</span> (messageCount != 0);
<a name="l00560"></a>00560 
<a name="l00561"></a>00561                 lword byteCount;
<a name="l00562"></a>00562                 <span class="keywordflow">do</span>
<a name="l00563"></a>00563                 {
<a name="l00564"></a>00564                         byteCount = ULONG_MAX;
<a name="l00565"></a>00565                         <span class="keywordtype">size_t</span> blockedBytes = <a class="code" href="class_buffered_transformation.html#a27ac15af3ef43c5ad1e9db5812025fcd" title="upon return, byteCount contains number of bytes that have finished being transfered, and returns the number of bytes left in the current transfer block">TransferTo2</a>(target, byteCount, channel, blocking);
<a name="l00566"></a>00566                         <span class="keywordflow">if</span> (blockedBytes)
<a name="l00567"></a>00567                                 <span class="keywordflow">return</span> blockedBytes;
<a name="l00568"></a>00568                 }
<a name="l00569"></a>00569                 <span class="keywordflow">while</span> (byteCount != 0);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571                 <span class="keywordflow">return</span> 0;
<a name="l00572"></a>00572         }
<a name="l00573"></a>00573 }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 <span class="keywordtype">void</span> BufferedTransformation::CopyAllTo(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> &amp;target, <span class="keyword">const</span> std::string &amp;channel)<span class="keyword"> const</span>
<a name="l00576"></a>00576 <span class="keyword"></span>{
<a name="l00577"></a>00577         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00578"></a>00578                 <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;CopyAllTo(target, channel);
<a name="l00579"></a>00579         <span class="keywordflow">else</span>
<a name="l00580"></a>00580         {
<a name="l00581"></a>00581                 assert(!NumberOfMessageSeries());
<a name="l00582"></a>00582                 <span class="keywordflow">while</span> (CopyMessagesTo(target, UINT_MAX, channel)) {}
<a name="l00583"></a>00583         }
<a name="l00584"></a>00584 }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586 <span class="keywordtype">void</span> BufferedTransformation::SetRetrievalChannel(<span class="keyword">const</span> std::string &amp;channel)
<a name="l00587"></a>00587 {
<a name="l00588"></a>00588         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>())
<a name="l00589"></a>00589                 <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;SetRetrievalChannel(channel);
<a name="l00590"></a>00590 }
<a name="l00591"></a>00591 
<a name="l00592"></a>00592 <span class="keywordtype">size_t</span> BufferedTransformation::ChannelPutWord16(<span class="keyword">const</span> std::string &amp;channel, word16 value, ByteOrder order, <span class="keywordtype">bool</span> blocking)
<a name="l00593"></a>00593 {
<a name="l00594"></a>00594         PutWord(<span class="keyword">false</span>, order, m_buf, value);
<a name="l00595"></a>00595         <span class="keywordflow">return</span> ChannelPut(channel, m_buf, 2, blocking);
<a name="l00596"></a>00596 }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 <span class="keywordtype">size_t</span> BufferedTransformation::ChannelPutWord32(<span class="keyword">const</span> std::string &amp;channel, word32 value, ByteOrder order, <span class="keywordtype">bool</span> blocking)
<a name="l00599"></a>00599 {
<a name="l00600"></a>00600         PutWord(<span class="keyword">false</span>, order, m_buf, value);
<a name="l00601"></a>00601         <span class="keywordflow">return</span> ChannelPut(channel, m_buf, 4, blocking);
<a name="l00602"></a>00602 }
<a name="l00603"></a>00603 
<a name="l00604"></a><a class="code" href="class_buffered_transformation.html#a92c60616792d7bce5cd41eaffbd1c3cc">00604</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#a92c60616792d7bce5cd41eaffbd1c3cc" title="input a 16-bit word">BufferedTransformation::PutWord16</a>(word16 value, ByteOrder order, <span class="keywordtype">bool</span> blocking)
<a name="l00605"></a>00605 {
<a name="l00606"></a>00606         <span class="keywordflow">return</span> ChannelPutWord16(DEFAULT_CHANNEL, value, order, blocking);
<a name="l00607"></a>00607 }
<a name="l00608"></a>00608 
<a name="l00609"></a><a class="code" href="class_buffered_transformation.html#affcc574867d51528afe3c96721ded075">00609</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#affcc574867d51528afe3c96721ded075" title="input a 32-bit word">BufferedTransformation::PutWord32</a>(word32 value, ByteOrder order, <span class="keywordtype">bool</span> blocking)
<a name="l00610"></a>00610 {
<a name="l00611"></a>00611         <span class="keywordflow">return</span> ChannelPutWord32(DEFAULT_CHANNEL, value, order, blocking);
<a name="l00612"></a>00612 }
<a name="l00613"></a>00613 
<a name="l00614"></a><a class="code" href="class_buffered_transformation.html#a452057f0d887ba0f2b6ec5373e290e91">00614</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#a452057f0d887ba0f2b6ec5373e290e91" title="try to peek at a 16-bit word">BufferedTransformation::PeekWord16</a>(word16 &amp;value, ByteOrder order)<span class="keyword"> const</span>
<a name="l00615"></a>00615 <span class="keyword"></span>{
<a name="l00616"></a>00616         byte buf[2] = {0, 0};
<a name="l00617"></a>00617         <span class="keywordtype">size_t</span> len = <a class="code" href="class_buffered_transformation.html#a5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">Peek</a>(buf, 2);
<a name="l00618"></a>00618 
<a name="l00619"></a>00619         <span class="keywordflow">if</span> (order)
<a name="l00620"></a>00620                 value = (buf[0] &lt;&lt; 8) | buf[1];
<a name="l00621"></a>00621         <span class="keywordflow">else</span>
<a name="l00622"></a>00622                 value = (buf[1] &lt;&lt; 8) | buf[0];
<a name="l00623"></a>00623 
<a name="l00624"></a>00624         <span class="keywordflow">return</span> len;
<a name="l00625"></a>00625 }
<a name="l00626"></a>00626 
<a name="l00627"></a><a class="code" href="class_buffered_transformation.html#aee19b1f5f0df32de2f33bf6bded3bae6">00627</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#aee19b1f5f0df32de2f33bf6bded3bae6" title="try to peek at a 32-bit word">BufferedTransformation::PeekWord32</a>(word32 &amp;value, ByteOrder order)<span class="keyword"> const</span>
<a name="l00628"></a>00628 <span class="keyword"></span>{
<a name="l00629"></a>00629         byte buf[4] = {0, 0, 0, 0};
<a name="l00630"></a>00630         <span class="keywordtype">size_t</span> len = <a class="code" href="class_buffered_transformation.html#a5fa048faf8c043ad57ae0a8911070090" title="peek at the next byte without removing it from the output buffer">Peek</a>(buf, 4);
<a name="l00631"></a>00631 
<a name="l00632"></a>00632         <span class="keywordflow">if</span> (order)
<a name="l00633"></a>00633                 value = (buf[0] &lt;&lt; 24) | (buf[1] &lt;&lt; 16) | (buf[2] &lt;&lt; 8) | buf [3];
<a name="l00634"></a>00634         <span class="keywordflow">else</span>
<a name="l00635"></a>00635                 value = (buf[3] &lt;&lt; 24) | (buf[2] &lt;&lt; 16) | (buf[1] &lt;&lt; 8) | buf [0];
<a name="l00636"></a>00636 
<a name="l00637"></a>00637         <span class="keywordflow">return</span> len;
<a name="l00638"></a>00638 }
<a name="l00639"></a>00639 
<a name="l00640"></a><a class="code" href="class_buffered_transformation.html#a1ac50bcb2d279c3c6aef6858dab3eeb7">00640</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#a1ac50bcb2d279c3c6aef6858dab3eeb7" title="try to retrieve a 16-bit word">BufferedTransformation::GetWord16</a>(word16 &amp;value, ByteOrder order)
<a name="l00641"></a>00641 {
<a name="l00642"></a>00642         <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)<a class="code" href="class_buffered_transformation.html#a0c25529ded99db20ad35ccef3f7234e6" title="discard skipMax bytes from the output buffer">Skip</a>(<a class="code" href="class_buffered_transformation.html#a452057f0d887ba0f2b6ec5373e290e91" title="try to peek at a 16-bit word">PeekWord16</a>(value, order));
<a name="l00643"></a>00643 }
<a name="l00644"></a>00644 
<a name="l00645"></a><a class="code" href="class_buffered_transformation.html#a69c064d931db3a8631c1138827d67e2f">00645</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_transformation.html#a69c064d931db3a8631c1138827d67e2f" title="try to retrieve a 32-bit word">BufferedTransformation::GetWord32</a>(word32 &amp;value, ByteOrder order)
<a name="l00646"></a>00646 {
<a name="l00647"></a>00647         <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)<a class="code" href="class_buffered_transformation.html#a0c25529ded99db20ad35ccef3f7234e6" title="discard skipMax bytes from the output buffer">Skip</a>(<a class="code" href="class_buffered_transformation.html#aee19b1f5f0df32de2f33bf6bded3bae6" title="try to peek at a 32-bit word">PeekWord32</a>(value, order));
<a name="l00648"></a>00648 }
<a name="l00649"></a>00649 
<a name="l00650"></a><a class="code" href="class_buffered_transformation.html#a9f6cbec970dcb509b23a08fb28b3e055">00650</a> <span class="keywordtype">void</span> <a class="code" href="class_buffered_transformation.html#a9f6cbec970dcb509b23a08fb28b3e055" title="add newAttachment to the end of attachment chain">BufferedTransformation::Attach</a>(<a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *newOut)
<a name="l00651"></a>00651 {
<a name="l00652"></a>00652         <span class="keywordflow">if</span> (<a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>() &amp;&amp; <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a20112606fc006c56f1561653cabd9542" title="returns whether this object allows attachment">Attachable</a>())
<a name="l00653"></a>00653                 <a class="code" href="class_buffered_transformation.html#aba6bbc169e26ed77a6bb5d50f91abda0" title="returns the object immediately attached to this object or NULL for no attachment">AttachedTransformation</a>()-&gt;<a class="code" href="class_buffered_transformation.html#a9f6cbec970dcb509b23a08fb28b3e055" title="add newAttachment to the end of attachment chain">Attach</a>(newOut);
<a name="l00654"></a>00654         <span class="keywordflow">else</span>
<a name="l00655"></a>00655                 <a class="code" href="class_buffered_transformation.html#a424737ad6b93e393dc43c3edb1223c3d" title="delete the current attachment chain and replace it with newAttachment">Detach</a>(newOut);
<a name="l00656"></a>00656 }
<a name="l00657"></a>00657 
<a name="l00658"></a><a class="code" href="class_generatable_crypto_material.html#a38d492343c32e530a5c2781b5797f755">00658</a> <span class="keywordtype">void</span> <a class="code" href="class_generatable_crypto_material.html#a38d492343c32e530a5c2781b5797f755" title="calls the above function with a NameValuePairs object that just specifies &amp;quot;KeySize&amp;quot;">GeneratableCryptoMaterial::GenerateRandomWithKeySize</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keySize)
<a name="l00659"></a>00659 {
<a name="l00660"></a>00660         <a class="code" href="class_generatable_crypto_material.html#abe368b52db1ca7079b690f2d6e605f7a" title="generate a random key or crypto parameters">GenerateRandom</a>(rng, MakeParameters(<span class="stringliteral">&quot;KeySize&quot;</span>, (<span class="keywordtype">int</span>)keySize));
<a name="l00661"></a>00661 }
<a name="l00662"></a>00662 
<a name="l00663"></a><a class="code" href="class_p_k___default_encryption_filter.html">00663</a> <span class="keyword">class </span><a class="code" href="class_p_k___default_encryption_filter.html">PK_DefaultEncryptionFilter</a> : <span class="keyword">public</span> <a class="code" href="class_unflushable.html" title="_">Unflushable</a>&lt;Filter&gt;
<a name="l00664"></a>00664 {
<a name="l00665"></a>00665 <span class="keyword">public</span>:
<a name="l00666"></a>00666         <a class="code" href="class_p_k___default_encryption_filter.html">PK_DefaultEncryptionFilter</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <span class="keyword">const</span> <a class="code" href="class_p_k___encryptor.html" title="interface for public-key encryptors">PK_Encryptor</a> &amp;encryptor, <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *attachment, <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;parameters)
<a name="l00667"></a>00667                 : m_rng(rng), m_encryptor(encryptor), m_parameters(parameters)
<a name="l00668"></a>00668         {
<a name="l00669"></a>00669                 Detach(attachment);
<a name="l00670"></a>00670         }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672         <span class="keywordtype">size_t</span> Put2(<span class="keyword">const</span> byte *inString, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> messageEnd, <span class="keywordtype">bool</span> blocking)
<a name="l00673"></a>00673         {
<a name="l00674"></a>00674                 FILTER_BEGIN;
<a name="l00675"></a>00675                 m_plaintextQueue.<a class="code" href="class_buffered_transformation.html#ae70658b0d271f8e114ac6c3cc9774ede" title="input a byte for processing">Put</a>(inString, length);
<a name="l00676"></a>00676 
<a name="l00677"></a>00677                 <span class="keywordflow">if</span> (messageEnd)
<a name="l00678"></a>00678                 {
<a name="l00679"></a>00679                         {
<a name="l00680"></a>00680                         <span class="keywordtype">size_t</span> plaintextLength;
<a name="l00681"></a>00681                         <span class="keywordflow">if</span> (!SafeConvert(m_plaintextQueue.CurrentSize(), plaintextLength))
<a name="l00682"></a>00682                                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(<span class="stringliteral">&quot;PK_DefaultEncryptionFilter: plaintext too long&quot;</span>);
<a name="l00683"></a>00683                         <span class="keywordtype">size_t</span> ciphertextLength = m_encryptor.<a class="code" href="class_p_k___crypto_system.html#abf04a4e08fb69a1a118bad3e998ef6a6" title="calculate length of ciphertext given length of plaintext">CiphertextLength</a>(plaintextLength);
<a name="l00684"></a>00684 
<a name="l00685"></a>00685                         <a class="code" href="class_sec_block.html">SecByteBlock</a> plaintext(plaintextLength);
<a name="l00686"></a>00686                         m_plaintextQueue.<a class="code" href="class_byte_queue.html#a19413e3aa72b749e3771d617e8eca632" title="try to retrieve a single byte">Get</a>(plaintext, plaintextLength);
<a name="l00687"></a>00687                         m_ciphertext.<a class="code" href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a" title="change size and preserve contents">resize</a>(ciphertextLength);
<a name="l00688"></a>00688                         m_encryptor.<a class="code" href="class_p_k___encryptor.html#aecb519bc1cb0b261698be999bb5c8961" title="encrypt a byte string">Encrypt</a>(m_rng, plaintext, plaintextLength, m_ciphertext, m_parameters);
<a name="l00689"></a>00689                         }
<a name="l00690"></a>00690                         
<a name="l00691"></a>00691                         FILTER_OUTPUT(1, m_ciphertext, m_ciphertext.size(), messageEnd);
<a name="l00692"></a>00692                 }
<a name="l00693"></a>00693                 FILTER_END_NO_MESSAGE_END;
<a name="l00694"></a>00694         }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696         <a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;m_rng;
<a name="l00697"></a>00697         <span class="keyword">const</span> <a class="code" href="class_p_k___encryptor.html" title="interface for public-key encryptors">PK_Encryptor</a> &amp;m_encryptor;
<a name="l00698"></a>00698         <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;m_parameters;
<a name="l00699"></a>00699         <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> m_plaintextQueue;
<a name="l00700"></a>00700         <a class="code" href="class_sec_block.html">SecByteBlock</a> m_ciphertext;
<a name="l00701"></a>00701 };
<a name="l00702"></a>00702 
<a name="l00703"></a><a class="code" href="class_p_k___encryptor.html#a66b9a0c99f5258f11b02f71d776ff4a2">00703</a> <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> * <a class="code" href="class_p_k___encryptor.html#a66b9a0c99f5258f11b02f71d776ff4a2" title="create a new encryption filter">PK_Encryptor::CreateEncryptionFilter</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *attachment, <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;parameters)<span class="keyword"> const</span>
<a name="l00704"></a>00704 <span class="keyword"></span>{
<a name="l00705"></a>00705         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_p_k___default_encryption_filter.html">PK_DefaultEncryptionFilter</a>(rng, *<span class="keyword">this</span>, attachment, parameters);
<a name="l00706"></a>00706 }
<a name="l00707"></a>00707 
<a name="l00708"></a><a class="code" href="class_p_k___default_decryption_filter.html">00708</a> <span class="keyword">class </span><a class="code" href="class_p_k___default_decryption_filter.html">PK_DefaultDecryptionFilter</a> : <span class="keyword">public</span> <a class="code" href="class_unflushable.html" title="_">Unflushable</a>&lt;Filter&gt;
<a name="l00709"></a>00709 {
<a name="l00710"></a>00710 <span class="keyword">public</span>:
<a name="l00711"></a>00711         <a class="code" href="class_p_k___default_decryption_filter.html">PK_DefaultDecryptionFilter</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <span class="keyword">const</span> <a class="code" href="class_p_k___decryptor.html" title="interface for public-key decryptors">PK_Decryptor</a> &amp;decryptor, <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *attachment, <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;parameters)
<a name="l00712"></a>00712                 : m_rng(rng), m_decryptor(decryptor), m_parameters(parameters)
<a name="l00713"></a>00713         {
<a name="l00714"></a>00714                 Detach(attachment);
<a name="l00715"></a>00715         }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717         <span class="keywordtype">size_t</span> Put2(<span class="keyword">const</span> byte *inString, <span class="keywordtype">size_t</span> length, <span class="keywordtype">int</span> messageEnd, <span class="keywordtype">bool</span> blocking)
<a name="l00718"></a>00718         {
<a name="l00719"></a>00719                 FILTER_BEGIN;
<a name="l00720"></a>00720                 m_ciphertextQueue.<a class="code" href="class_buffered_transformation.html#ae70658b0d271f8e114ac6c3cc9774ede" title="input a byte for processing">Put</a>(inString, length);
<a name="l00721"></a>00721 
<a name="l00722"></a>00722                 <span class="keywordflow">if</span> (messageEnd)
<a name="l00723"></a>00723                 {
<a name="l00724"></a>00724                         {
<a name="l00725"></a>00725                         <span class="keywordtype">size_t</span> ciphertextLength;
<a name="l00726"></a>00726                         <span class="keywordflow">if</span> (!SafeConvert(m_ciphertextQueue.CurrentSize(), ciphertextLength))
<a name="l00727"></a>00727                                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_argument.html" title="exception thrown when an invalid argument is detected">InvalidArgument</a>(<span class="stringliteral">&quot;PK_DefaultDecryptionFilter: ciphertext too long&quot;</span>);
<a name="l00728"></a>00728                         <span class="keywordtype">size_t</span> maxPlaintextLength = m_decryptor.<a class="code" href="class_p_k___crypto_system.html#aa4a3552c933a36b3aea26f31d00bee9b" title="maximum length of plaintext for a given ciphertext length">MaxPlaintextLength</a>(ciphertextLength);
<a name="l00729"></a>00729 
<a name="l00730"></a>00730                         <a class="code" href="class_sec_block.html">SecByteBlock</a> ciphertext(ciphertextLength);
<a name="l00731"></a>00731                         m_ciphertextQueue.<a class="code" href="class_byte_queue.html#a19413e3aa72b749e3771d617e8eca632" title="try to retrieve a single byte">Get</a>(ciphertext, ciphertextLength);
<a name="l00732"></a>00732                         m_plaintext.<a class="code" href="class_sec_block.html#af9e98d3f4a7af1156fcf3e6e68f4ae5a" title="change size and preserve contents">resize</a>(maxPlaintextLength);
<a name="l00733"></a>00733                         m_result = m_decryptor.<a class="code" href="class_p_k___decryptor.html#ab7466675ed050c440c16508f8a88cac1" title="decrypt a byte string, and return the length of plaintext">Decrypt</a>(m_rng, ciphertext, ciphertextLength, m_plaintext, m_parameters);
<a name="l00734"></a>00734                         <span class="keywordflow">if</span> (!m_result.isValidCoding)
<a name="l00735"></a>00735                                 <span class="keywordflow">throw</span> <a class="code" href="class_invalid_ciphertext.html" title="exception thrown by decryption filters when trying to decrypt an invalid ciphertext">InvalidCiphertext</a>(m_decryptor.<a class="code" href="class_algorithm.html#acd21c6715add4884fa043eaf51655039" title="returns name of this algorithm, not universally implemented yet">AlgorithmName</a>() + <span class="stringliteral">&quot;: invalid ciphertext&quot;</span>);
<a name="l00736"></a>00736                         }
<a name="l00737"></a>00737 
<a name="l00738"></a>00738                         FILTER_OUTPUT(1, m_plaintext, m_result.messageLength, messageEnd);
<a name="l00739"></a>00739                 }
<a name="l00740"></a>00740                 FILTER_END_NO_MESSAGE_END;
<a name="l00741"></a>00741         }
<a name="l00742"></a>00742 
<a name="l00743"></a>00743         <a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;m_rng;
<a name="l00744"></a>00744         <span class="keyword">const</span> <a class="code" href="class_p_k___decryptor.html" title="interface for public-key decryptors">PK_Decryptor</a> &amp;m_decryptor;
<a name="l00745"></a>00745         <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;m_parameters;
<a name="l00746"></a>00746         <a class="code" href="class_byte_queue.html" title="Byte Queue.">ByteQueue</a> m_ciphertextQueue;
<a name="l00747"></a>00747         <a class="code" href="class_sec_block.html">SecByteBlock</a> m_plaintext;
<a name="l00748"></a>00748         <a class="code" href="struct_decoding_result.html" title="used to return decoding results">DecodingResult</a> m_result;
<a name="l00749"></a>00749 };
<a name="l00750"></a>00750 
<a name="l00751"></a><a class="code" href="class_p_k___decryptor.html#a495d8801c8042d3c3576e00965bd9bc8">00751</a> <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> * <a class="code" href="class_p_k___decryptor.html#a495d8801c8042d3c3576e00965bd9bc8" title="create a new decryption filter">PK_Decryptor::CreateDecryptionFilter</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <a class="code" href="class_buffered_transformation.html" title="interface for buffered transformations">BufferedTransformation</a> *attachment, <span class="keyword">const</span> <a class="code" href="class_name_value_pairs.html" title="interface for retrieving values given their names">NameValuePairs</a> &amp;parameters)<span class="keyword"> const</span>
<a name="l00752"></a>00752 <span class="keyword"></span>{
<a name="l00753"></a>00753         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_p_k___default_decryption_filter.html">PK_DefaultDecryptionFilter</a>(rng, *<span class="keyword">this</span>, attachment, parameters);
<a name="l00754"></a>00754 }
<a name="l00755"></a>00755 
<a name="l00756"></a><a class="code" href="class_p_k___signer.html#a28de428238711210d765b6389062e6e2">00756</a> <span class="keywordtype">size_t</span> <a class="code" href="class_p_k___signer.html#a28de428238711210d765b6389062e6e2" title="sign and delete messageAccumulator (even in case of exception thrown)">PK_Signer::Sign</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <a class="code" href="class_p_k___message_accumulator.html" title="interface for accumulating messages to be signed or verified">PK_MessageAccumulator</a> *messageAccumulator, byte *signature)<span class="keyword"> const</span>
<a name="l00757"></a>00757 <span class="keyword"></span>{
<a name="l00758"></a>00758         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(messageAccumulator);
<a name="l00759"></a>00759         <span class="keywordflow">return</span> <a class="code" href="class_p_k___signer.html#afbcf3f00d761f681839ae6264743dd34" title="sign and restart messageAccumulator">SignAndRestart</a>(rng, *m, signature, <span class="keyword">false</span>);
<a name="l00760"></a>00760 }
<a name="l00761"></a>00761 
<a name="l00762"></a><a class="code" href="class_p_k___signer.html#a08920dfd51f5d0d8e5f77c8f20b56ce2">00762</a> <span class="keywordtype">size_t</span> <a class="code" href="class_p_k___signer.html#a08920dfd51f5d0d8e5f77c8f20b56ce2" title="sign a message">PK_Signer::SignMessage</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <span class="keyword">const</span> byte *message, <span class="keywordtype">size_t</span> messageLen, byte *signature)<span class="keyword"> const</span>
<a name="l00763"></a>00763 <span class="keyword"></span>{
<a name="l00764"></a>00764         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(<a class="code" href="class_p_k___signer.html#aff85d006e814ccc8ac943b145a0bfaf9" title="create a new HashTransformation to accumulate the message to be signed">NewSignatureAccumulator</a>(rng));
<a name="l00765"></a>00765         m-&gt;Update(message, messageLen);
<a name="l00766"></a>00766         <span class="keywordflow">return</span> <a class="code" href="class_p_k___signer.html#afbcf3f00d761f681839ae6264743dd34" title="sign and restart messageAccumulator">SignAndRestart</a>(rng, *m, signature, <span class="keyword">false</span>);
<a name="l00767"></a>00767 }
<a name="l00768"></a>00768 
<a name="l00769"></a><a class="code" href="class_p_k___signer.html#a76eb862d0cb8d80e0bee7ad52a0da707">00769</a> <span class="keywordtype">size_t</span> <a class="code" href="class_p_k___signer.html#a76eb862d0cb8d80e0bee7ad52a0da707" title="sign a recoverable message">PK_Signer::SignMessageWithRecovery</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, <span class="keyword">const</span> byte *recoverableMessage, <span class="keywordtype">size_t</span> recoverableMessageLength, 
<a name="l00770"></a>00770         <span class="keyword">const</span> byte *nonrecoverableMessage, <span class="keywordtype">size_t</span> nonrecoverableMessageLength, byte *signature)<span class="keyword"> const</span>
<a name="l00771"></a>00771 <span class="keyword"></span>{
<a name="l00772"></a>00772         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(<a class="code" href="class_p_k___signer.html#aff85d006e814ccc8ac943b145a0bfaf9" title="create a new HashTransformation to accumulate the message to be signed">NewSignatureAccumulator</a>(rng));
<a name="l00773"></a>00773         InputRecoverableMessage(*m, recoverableMessage, recoverableMessageLength);
<a name="l00774"></a>00774         m-&gt;Update(nonrecoverableMessage, nonrecoverableMessageLength);
<a name="l00775"></a>00775         <span class="keywordflow">return</span> <a class="code" href="class_p_k___signer.html#afbcf3f00d761f681839ae6264743dd34" title="sign and restart messageAccumulator">SignAndRestart</a>(rng, *m, signature, <span class="keyword">false</span>);
<a name="l00776"></a>00776 }
<a name="l00777"></a>00777 
<a name="l00778"></a><a class="code" href="class_p_k___verifier.html#a002461c71eaacb022a0d169975a6f752">00778</a> <span class="keywordtype">bool</span> <a class="code" href="class_p_k___verifier.html#a002461c71eaacb022a0d169975a6f752" title="check whether messageAccumulator contains a valid signature and message, and delete messageAccumulato...">PK_Verifier::Verify</a>(<a class="code" href="class_p_k___message_accumulator.html" title="interface for accumulating messages to be signed or verified">PK_MessageAccumulator</a> *messageAccumulator)<span class="keyword"> const</span>
<a name="l00779"></a>00779 <span class="keyword"></span>{
<a name="l00780"></a>00780         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(messageAccumulator);
<a name="l00781"></a>00781         <span class="keywordflow">return</span> <a class="code" href="class_p_k___verifier.html#a36e176dc8a0d3f924938cb2b07021f28" title="check whether messageAccumulator contains a valid signature and message, and restart messageAccumulat...">VerifyAndRestart</a>(*m);
<a name="l00782"></a>00782 }
<a name="l00783"></a>00783 
<a name="l00784"></a><a class="code" href="class_p_k___verifier.html#a4640a967fd291f8be86c1b721dc73b2d">00784</a> <span class="keywordtype">bool</span> <a class="code" href="class_p_k___verifier.html#a4640a967fd291f8be86c1b721dc73b2d" title="check whether input signature is a valid signature for input message">PK_Verifier::VerifyMessage</a>(<span class="keyword">const</span> byte *message, <span class="keywordtype">size_t</span> messageLen, <span class="keyword">const</span> byte *signature, <span class="keywordtype">size_t</span> signatureLength)<span class="keyword"> const</span>
<a name="l00785"></a>00785 <span class="keyword"></span>{
<a name="l00786"></a>00786         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(<a class="code" href="class_p_k___verifier.html#acd874268dab653dde01409fc9dfd2069" title="create a new HashTransformation to accumulate the message to be verified">NewVerificationAccumulator</a>());
<a name="l00787"></a>00787         <a class="code" href="class_p_k___verifier.html#a515aa448e7fc3a5c6e422e65500ab507" title="input signature into a message accumulator">InputSignature</a>(*m, signature, signatureLength);
<a name="l00788"></a>00788         m-&gt;Update(message, messageLen);
<a name="l00789"></a>00789         <span class="keywordflow">return</span> <a class="code" href="class_p_k___verifier.html#a36e176dc8a0d3f924938cb2b07021f28" title="check whether messageAccumulator contains a valid signature and message, and restart messageAccumulat...">VerifyAndRestart</a>(*m);
<a name="l00790"></a>00790 }
<a name="l00791"></a>00791 
<a name="l00792"></a><a class="code" href="class_p_k___verifier.html#a25a928c76d7bc73e1a04d85266b46382">00792</a> <a class="code" href="struct_decoding_result.html" title="used to return decoding results">DecodingResult</a> <a class="code" href="class_p_k___verifier.html#a25a928c76d7bc73e1a04d85266b46382" title="recover a message from its signature">PK_Verifier::Recover</a>(byte *recoveredMessage, <a class="code" href="class_p_k___message_accumulator.html" title="interface for accumulating messages to be signed or verified">PK_MessageAccumulator</a> *messageAccumulator)<span class="keyword"> const</span>
<a name="l00793"></a>00793 <span class="keyword"></span>{
<a name="l00794"></a>00794         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(messageAccumulator);
<a name="l00795"></a>00795         <span class="keywordflow">return</span> <a class="code" href="class_p_k___verifier.html#a6612ff44a274594890419ae75d260cce" title="recover a message from its signature">RecoverAndRestart</a>(recoveredMessage, *m);
<a name="l00796"></a>00796 }
<a name="l00797"></a>00797 
<a name="l00798"></a><a class="code" href="class_p_k___verifier.html#a95dff7c35894d953b54d09d1973787da">00798</a> <a class="code" href="struct_decoding_result.html" title="used to return decoding results">DecodingResult</a> <a class="code" href="class_p_k___verifier.html#a95dff7c35894d953b54d09d1973787da" title="recover a message from its signature">PK_Verifier::RecoverMessage</a>(byte *recoveredMessage, 
<a name="l00799"></a>00799         <span class="keyword">const</span> byte *nonrecoverableMessage, <span class="keywordtype">size_t</span> nonrecoverableMessageLength, 
<a name="l00800"></a>00800         <span class="keyword">const</span> byte *signature, <span class="keywordtype">size_t</span> signatureLength)<span class="keyword"> const</span>
<a name="l00801"></a>00801 <span class="keyword"></span>{
<a name="l00802"></a>00802         std::auto_ptr&lt;PK_MessageAccumulator&gt; m(<a class="code" href="class_p_k___verifier.html#acd874268dab653dde01409fc9dfd2069" title="create a new HashTransformation to accumulate the message to be verified">NewVerificationAccumulator</a>());
<a name="l00803"></a>00803         <a class="code" href="class_p_k___verifier.html#a515aa448e7fc3a5c6e422e65500ab507" title="input signature into a message accumulator">InputSignature</a>(*m, signature, signatureLength);
<a name="l00804"></a>00804         m-&gt;Update(nonrecoverableMessage, nonrecoverableMessageLength);
<a name="l00805"></a>00805         <span class="keywordflow">return</span> <a class="code" href="class_p_k___verifier.html#a6612ff44a274594890419ae75d260cce" title="recover a message from its signature">RecoverAndRestart</a>(recoveredMessage, *m);
<a name="l00806"></a>00806 }
<a name="l00807"></a>00807 
<a name="l00808"></a><a class="code" href="class_simple_key_agreement_domain.html#a75629cd8157dca667c6aff0562ca59af">00808</a> <span class="keywordtype">void</span> <a class="code" href="class_simple_key_agreement_domain.html#a75629cd8157dca667c6aff0562ca59af" title="generate private/public key pair">SimpleKeyAgreementDomain::GenerateKeyPair</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, byte *privateKey, byte *publicKey)<span class="keyword"> const</span>
<a name="l00809"></a>00809 <span class="keyword"></span>{
<a name="l00810"></a>00810         <a class="code" href="class_simple_key_agreement_domain.html#aee7a4929f8a1a77acd04e12fbcd0a0b1" title="generate private key">GeneratePrivateKey</a>(rng, privateKey);
<a name="l00811"></a>00811         <a class="code" href="class_simple_key_agreement_domain.html#a56d0957a43c48f3e6431868f564f574f" title="generate public key">GeneratePublicKey</a>(rng, privateKey, publicKey);
<a name="l00812"></a>00812 }
<a name="l00813"></a>00813 
<a name="l00814"></a><a class="code" href="class_authenticated_key_agreement_domain.html#ae2c306a6582c6e592ecb2c13abfd7c9f">00814</a> <span class="keywordtype">void</span> <a class="code" href="class_authenticated_key_agreement_domain.html#ae2c306a6582c6e592ecb2c13abfd7c9f" title="generate private/public key pair">AuthenticatedKeyAgreementDomain::GenerateStaticKeyPair</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, byte *privateKey, byte *publicKey)<span class="keyword"> const</span>
<a name="l00815"></a>00815 <span class="keyword"></span>{
<a name="l00816"></a>00816         <a class="code" href="class_authenticated_key_agreement_domain.html#a00d9b12028e9ecb61af6d0f312965c6f" title="generate static private key">GenerateStaticPrivateKey</a>(rng, privateKey);
<a name="l00817"></a>00817         <a class="code" href="class_authenticated_key_agreement_domain.html#a853885a901ac7c4f8c51fd177df5d96c" title="generate static public key">GenerateStaticPublicKey</a>(rng, privateKey, publicKey);
<a name="l00818"></a>00818 }
<a name="l00819"></a>00819 
<a name="l00820"></a><a class="code" href="class_authenticated_key_agreement_domain.html#a18f1fc5fa590be704d53759e44fba093">00820</a> <span class="keywordtype">void</span> <a class="code" href="class_authenticated_key_agreement_domain.html#a18f1fc5fa590be704d53759e44fba093" title="generate private/public key pair">AuthenticatedKeyAgreementDomain::GenerateEphemeralKeyPair</a>(<a class="code" href="class_random_number_generator.html" title="interface for random number generators">RandomNumberGenerator</a> &amp;rng, byte *privateKey, byte *publicKey)<span class="keyword"> const</span>
<a name="l00821"></a>00821 <span class="keyword"></span>{
<a name="l00822"></a>00822         <a class="code" href="class_authenticated_key_agreement_domain.html#ab6280d3bf8ad1dd2aa976910b81502f8" title="generate ephemeral private key">GenerateEphemeralPrivateKey</a>(rng, privateKey);
<a name="l00823"></a>00823         <a class="code" href="class_authenticated_key_agreement_domain.html#a9d1bc83a77f44af6616da42c33b3bc49" title="generate ephemeral public key">GenerateEphemeralPublicKey</a>(rng, privateKey, publicKey);
<a name="l00824"></a>00824 }
<a name="l00825"></a>00825 
<a name="l00826"></a>00826 NAMESPACE_END
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Aug 9 2010 15:56:33 for Crypto++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
